#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://nagios-plugins.org/doc/guidelines.html

__author__  = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020011901'

DESCRIPTION = 'Checks whether a network port is reachable.'

DEFAULT_HOSTNAME = 'localhost'
DEFAULT_PORT = 22
DEFAULT_STATE = 'warn'
DEFAULT_TIMEOUT = 1.5
DEFAULT_TYPE = 'tcp'


#====================

from lib.globals import *

import argparse
from traceback import print_exc
import socket

from lib.output import unpack_perfdata


def define_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument('-H', '--hostname', 
        help = 'The host or ip address to check. Default: %(default)s',
        dest = 'HOSTNAME',
        default = DEFAULT_HOSTNAME,
        )

    parser.add_argument('-p', '--port', 
        help = 'The port number. Default: %(default)s',
        dest = 'PORT',
        type = int,
        default = DEFAULT_PORT,
        )

    parser.add_argument('--portname', 
        help = 'The display name of the port.',
        dest = 'PORTNAME',
        )

    parser.add_argument('--state', 
        help = 'The state that has to be returned. Default: %(default)s',
        dest = 'STATE',
        default = DEFAULT_STATE,
        choices = ['warn', 'crit'],
        )

    parser.add_argument('-t', '--timeout', 
        help = 'Network timeout. Default: %(default)s',
        dest = 'TIMEOUT',
        type = float,
        default = DEFAULT_TIMEOUT,
        )

    parser.add_argument('--type', 
        help = 'Connection type. Default: %(default)s',
        dest = 'TYPE',
        default = DEFAULT_TYPE,
        choices = ['tcp', 'tcp6'],
        )

    parser.add_argument('-V', '--version',
        action = 'version',
        version = '%(prog)s: v{} by {}'.format(__version__, __author__)
        )

    return parser.parse_args()


def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        parsed = define_args()
    except SystemExit as e:
        exit(STATE_UNKNOWN)

    HOSTNAME = parsed.HOSTNAME
    PORT = parsed.PORT
    PORTNAME = parsed.PORTNAME
    STATE = STATE_WARN if parsed.STATE == 'warn' else STATE_CRIT
    TIMEOUT = parsed.TIMEOUT
    TYPE = parsed.TYPE

    if TYPE == 'tcp':
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    else:
        sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
    sock.settimeout(TIMEOUT)

    try:
        # Works fine for tcp connections, but not for udp. The port response for udp is based on the target application and is not standard like tcp.
        if sock.connect_ex((HOSTNAME, PORT)) == 0:
            state = STATE_OK
        else:
            state = STATE
    except:
        print('Cannot initiate a connection to {}:{}/{}.'.format(HOSTNAME, PORT, TYPE))
        exit(STATE_UNKNOWN)

    sock.close()

    print('{}:{}/{} is {}.'.format(HOSTNAME, PORTNAME if PORTNAME else PORT, TYPE, 'reachable' if state == STATE_OK else 'unreachable'))
    exit(state)


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print_exc()
        exit(STATE_UNKNOWN)
