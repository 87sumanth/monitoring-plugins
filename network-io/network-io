#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://nagios-plugins.org/doc/guidelines.html


__author__  = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020010901'

DESCRIPTION = 'Checks network IO for all interfaces. We only consider inferfaces that have a MAC-Address, therefore we ignore `lo`.'

DEFAULT_COUNT = 5       # measurements; if check runs once per minute, this is a 5 minute interval
DB = '/tmp/network-io.db'

RX_ERR_DEFAULT_WARN = 1
RX_ERR_DEFAULT_CRIT = None

RX_DRP_DEFAULT_WARN = 1
RX_DRP_DEFAULT_CRIT = None

RX_OVRUN_DEFAULT_WARN = 1
RX_OVRUN_DEFAULT_CRIT = None

TX_ERR_DEFAULT_WARN = 1
TX_ERR_DEFAULT_CRIT = None

TX_DRP_DEFAULT_WARN = 1
TX_DRP_DEFAULT_CRIT = None

TX_COLL_DEFAULT_WARN = 1
TX_COLL_DEFAULT_CRIT = None

DEFAULT_INTERFACES = [['*', 1000, 80, 90]]

#====================
import argparse
import sqlite3
import psutil
import time

from lib.globals import *
from lib.utils import execute_command
from lib.output import unpack_perfdata, bytes2human, state_to_string, format_as_table
from lib.parse_arguments import csv
from lib.parse_input import evaluate_greater


def define_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument('-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
        )

    parser.add_argument('-i', '--interface',
        help = 'Set the speed and percentage warning / critical thresholds per interface, in the format "interface, speed_mbps, warn_percentage, crit_percentage". Default for all interfaces: {}'.format(DEFAULT_INTERFACES),
        dest = 'INTERFACES',
        type = csv,
        # default = DEFAULT_INTERFACES, does not work, as this would be always added to parsed.INTERFACES. Default is handled in the code below
        action = 'append',
        )

    parser.add_argument('--count',
        help = 'Number of times the value has to be above the given thresholds. Default: %(default)s',
        dest = 'COUNT',
        type = int,
        default = DEFAULT_COUNT,
        )

    return parser.parse_args()


# https://docs.python.org/2/library/sqlite3.html
def insert_into_db(db, tablename, values, count):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    # create table if it does not exist
    c.execute('''
        CREATE TABLE IF NOT EXISTS "{}" (
            bytes_sent INTEGER NOT NULL,
            tx_rate REAL NOT NULL,
            bytes_recv INTEGER NOT NULL,
            rx_rate REAL NOT NULL,
            errin INTEGER NOT NULL,
            errout INTEGER NOT NULL,
            dropin INTEGER NOT NULL,
            dropout INTEGER NOT NULL,
            unix_timestamp INTEGER NOT NULL
        )
        '''.format(tablename))

    # insert a row of data (named values from a dictionary)
    c.execute('INSERT INTO "{}" VALUES (:bytes_sent, :tx_rate, :bytes_recv, :rx_rate, :errin, :errout, :dropin, :dropout, :unix_timestamp)'.format(tablename), values)

    # leave only the latest "count" records, using the sqlite built-in "rowid"
    c.execute('''
        DELETE FROM "{tablename}"
        WHERE rowid IN (
            SELECT rowid
            FROM "{tablename}"
            ORDER BY rowid DESC
            LIMIT -1
            OFFSET ?
        )
        '''.format(tablename=tablename), (count, ))

    # Save (commit) the changes
    conn.commit()

    # We can close the connection if we are done with it.
    # Just be sure any changes have been committed or they will be lost.
    conn.close()


def get_from_db(db, tablename):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    c.execute('''
        SELECT *
        FROM "{}"
        ORDER BY rowid DESC
        '''.format(tablename))
    result = c.fetchall()

    # We can close the connection if we are done with it.
    # Just be sure any changes have been committed or they will be lost.
    conn.close()

    return result


def evaluate_from_db(db, tablename, warn, crit, count):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    c.execute('''
        SELECT count(*)
        FROM "{}"
        WHERE tx_rate > ? or rx_rate > ?
        '''.format(tablename), (crit, crit))

    if c.fetchone()[0] == count:
        conn.close()
        return STATE_CRIT

    c.execute('''
        SELECT count(*)
        FROM "{}"
        WHERE tx_rate > ? or rx_rate > ?
        '''.format(tablename), (warn, warn))

    temp = c.fetchone()[0]
    print('temp: ' + str(temp))
    if temp == count:
        conn.close()
        return STATE_WARN
    
    # We can close the connection if we are done with it.
    conn.close()
    return STATE_OK


def main():    
    # parse the command line, exit with UNKNOWN if it fails
    try:
        parsed = define_args()
    except SystemExit as e:
        exit(STATE_UNKNOWN)

    thresholds = {}
    INTERFACES = parsed.INTERFACES if parsed.INTERFACES else DEFAULT_INTERFACES
    for interface in INTERFACES:
        thresholds[interface[0]] = [float(x) for x in interface[1:]] # convert speed, warn and crit to float, then add to dictionary based on ifname

    overall_state = STATE_OK
    table_data = []
    perfdata = ''
    highest_ifname = ''
    highest_rx_rate = 0
    highest_tx_rate = 0
    unix_timestamp = int(time.time())

    network_stats = psutil.net_io_counters(pernic=True)
    for ifname in network_stats:
        if ifname == 'lo':
            continue

        if '*' not in thresholds.keys()\
        and ifname not in thresholds.keys():
            continue

        stats = {}
        tablename = '{}_check_values'.format(ifname)
        interface_state = STATE_OK
        stats['unix_timestamp'] = unix_timestamp
        for stat in ['bytes_sent', 'bytes_recv', 'errin', 'errout', 'dropin', 'dropout']:
            if hasattr(network_stats[ifname], stat):
                stats[stat] = getattr(network_stats[ifname], stat)

        # try to get last stats
        try:
            last_stats = get_from_db(DB, tablename)
            # last_stats[0] = (bytes_sent, tx_rate, bytes_recv, rx_rate, errin, errout, dropin, dropout, unix_timestamp)
            pos_bytes_sent = 0
            pos_tx_rate = 1
            pos_bytes_recv = 2
            pos_rx_rate = 3
            pos_errin = 4
            pos_errout = 5
            pos_dropin = 6
            pos_dropout = 7
            pos_unix_timestamp = 8

            
            # first try the ifname, then '*', else None
            rx_rate_speed, rx_rate_warn_pcent, rx_rate_crit_pcent = thresholds.get(ifname, thresholds.get('*', None))
            rx_rate_warn = rx_rate_speed * rx_rate_warn_pcent * 0.01 * 10**6 # to percent, them from mbps to bps
            rx_rate_crit = rx_rate_speed * rx_rate_crit_pcent * 0.01 * 10**6

            tx_rate_speed, tx_rate_warn_pcent, tx_rate_crit_pcent = thresholds.get(ifname, thresholds.get('*', None))
            tx_rate_warn = tx_rate_speed * tx_rate_warn_pcent * 0.01 * 10**6
            tx_rate_crit = tx_rate_speed * tx_rate_crit_pcent * 0.01 * 10**6


            time_delta = int(stats['unix_timestamp']) - int(last_stats[0][pos_unix_timestamp])
            stats['rx_rate'] = (stats['bytes_recv'] - last_stats[0][pos_bytes_recv]) / time_delta * 8 # conversion from bytes/s to bits/s
            if stats['rx_rate'] < 0:
                stats['rx_rate'] = 0 # handle negative numbers due to eg reboots
            perfdata += unpack_perfdata('{}_RX_Rate'.format(ifname), stats['rx_rate'], None, rx_rate_warn, rx_rate_crit, 0, None)
            interface_state = get_greater_state(interface_state, evaluate_from_db(DB, tablename, rx_rate_warn, rx_rate_crit, parsed.COUNT))

            stats['tx_rate'] = (stats['bytes_sent'] - last_stats[0][pos_bytes_sent]) / time_delta * 8 # conversion from bytes/s to bits/s
            if stats['tx_rate'] < 0:
                stats['tx_rate'] = 0 # handle negative numbers due to eg reboots
            perfdata += unpack_perfdata('{}_TX_Rate'.format(ifname), stats['tx_rate'], None, tx_rate_warn, tx_rate_crit, 0, None)
            interface_state = get_greater_state(interface_state, evaluate_from_db(DB, tablename, rx_rate_warn, rx_rate_crit, parsed.COUNT))

            if stats['rx_rate'] >= highest_rx_rate\
            or stats['rx_rate'] >= highest_tx_rate:
                highest_ifname = ifname
                highest_rx_rate = stats['rx_rate']
                highest_tx_rate = stats['tx_rate']

            if stats['tx_rate'] >= highest_rx_rate\
            or stats['tx_rate'] >= highest_tx_rate:
                highest_ifname = ifname
                highest_rx_rate = stats['rx_rate']
                highest_tx_rate = stats['tx_rate']

            table_data.append({
                'ifname': '{} {}'.format(ifname, state_to_string(interface_state)),
                'rx_rate': '{}bps'.format(bytes2human(stats['rx_rate'])),
                'errin': stats['errin'],
                'dropin': stats['dropin'],
                'dropin': stats['dropin'],
                'tx_rate': '{}bps'.format(bytes2human(stats['tx_rate'])),
                'errout': stats['errout'],
                'dropout': stats['dropout'],
            })

            overall_state = get_greater_state(overall_state, interface_state)

        except sqlite3.OperationalError as e:
            print(e)
            stats['tx_rate'] = 0
            stats['rx_rate'] = 0

        # save trend data to local sqlite database, limited to "count" rows max.
        insert_into_db(DB, tablename, stats, parsed.COUNT)


    if overall_state == STATE_OK:
        msg = 'Everything is ok. {}: {}bps/{}bps (RX/TX)'.format(
            highest_ifname,
            bytes2human(highest_rx_rate),
            bytes2human(highest_tx_rate)
            )
    else:
        msg = 'One or more errors. {}: {}bps/{}bps (RX/TX)'.format(
            highest_ifname,
            bytes2human(highest_rx_rate),
            bytes2human(highest_tx_rate)
            )

    table = format_as_table(table_data, ['ifname', 'rx_rate', 'errin', 'dropin', 'dropin', 'tx_rate', 'errout', 'dropout'], ['ifname', 'rx_rate', 'errin', 'dropin', 'dropin', 'tx_rate', 'errout', 'dropout'], 'ifname')

    print(msg.strip() + '\n\n' + table + '|' + perfdata.strip())
    exit(overall_state)

if __name__ == '__main__':
    main()
