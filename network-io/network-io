#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://nagios-plugins.org/doc/guidelines.html


__author__  = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020011001'

DESCRIPTION = 'Checks network IO for all interfaces. We only consider inferfaces that have a MAC-Address, therefore we ignore `lo`.'

DEFAULT_COUNT = 5        # measurements; if check runs once per minute, this is a 5 minute interval
DEFAULT_TIMESPAN = 15    # minutes
DB = '/tmp/network-io.db'

DEFAULT_INTERFACES = [['*', 1000, 80, 90]]

#====================
import argparse
import sqlite3
import psutil
import time

from lib.globals import *
from lib.utils import execute_command
from lib.output import unpack_perfdata, bytes2human, state_to_string, format_as_table
from lib.parse_arguments import csv
from lib.parse_input import evaluate_greater


def define_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument('-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
        )

    parser.add_argument('-i', '--interface',
        help = 'Set the speed and percentage warning / critical thresholds per interface, in the format "interface, speed_mbps, warn_percentage, crit_percentage". Use "*" as the interface name to set thresholds for all interfaces. Default for all interfaces: {}'.format(DEFAULT_INTERFACES),
        dest = 'INTERFACES',
        type = csv,
        # default = DEFAULT_INTERFACES, # does not work, as this would be always added to parsed.INTERFACES. Default is handled in the code below
        action = 'append',
        )

    parser.add_argument('--count',
        help = 'Number of times the value has to be above the given thresholds. Default: %(default)s',
        dest = 'COUNT',
        type = int,
        default = DEFAULT_COUNT,
        )

    parser.add_argument('--timespan',
        help = 'The timespan in minutes for which a warning will be returned on an increase in drops or errors. Default: %(default)s min',
        dest = 'TIMESPAN',
        type = int,
        default = DEFAULT_TIMESPAN,
        )

    return parser.parse_args()


# https://docs.python.org/2/library/sqlite3.html
def insert_rate_values_into_db(db, tablename, values, count):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    # create table if it does not exist
    c.execute('''
        CREATE TABLE IF NOT EXISTS "{}" (
            bytes_sent INTEGER NOT NULL,
            tx_rate REAL NOT NULL,
            bytes_recv INTEGER NOT NULL,
            rx_rate REAL NOT NULL,
            unix_timestamp INTEGER NOT NULL
        )
        '''.format(tablename))

    # insert a row of data (named values from a dictionary)
    c.execute('INSERT INTO "{}" VALUES (:bytes_sent, :tx_rate, :bytes_recv, :rx_rate, :unix_timestamp)'.format(tablename), values)

    # leave only the latest "count" records, using the sqlite built-in "rowid"
    c.execute('''
        DELETE FROM "{tablename}"
        WHERE rowid IN (
            SELECT rowid
            FROM "{tablename}"
            ORDER BY rowid DESC
            LIMIT -1
            OFFSET ?
        )
        '''.format(tablename=tablename), (count, ))

    # Save (commit) the changes
    conn.commit()

    # We can close the connection if we are done with it.
    # Just be sure any changes have been committed or they will be lost.
    conn.close()


def insert_drp_err_values_into_db(db, tablename, values):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    # create table if it does not exist
    c.execute('''
        CREATE TABLE IF NOT EXISTS "{}" (
            errin INTEGER NOT NULL,
            errout INTEGER NOT NULL,
            dropin INTEGER NOT NULL,
            dropout INTEGER NOT NULL,
            unix_timestamp INTEGER NOT NULL
        )
        '''.format(tablename))

    # insert a row of data (named values from a dictionary)
    c.execute('INSERT INTO "{}" VALUES (:errin, :errout, :dropin, :dropout, :unix_timestamp)'.format(tablename), values)

    # leave only the latest record, using the sqlite built-in "rowid"
    c.execute('''
        DELETE FROM "{tablename}"
        WHERE rowid IN (
            SELECT rowid
            FROM "{tablename}"
            ORDER BY rowid DESC
            LIMIT -1
            OFFSET 1
        )
        '''.format(tablename=tablename))

    # Save (commit) the changes
    conn.commit()

    # We can close the connection if we are done with it.
    # Just be sure any changes have been committed or they will be lost.
    conn.close()


def get_from_db(db, tablename):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    c.execute('''
        SELECT *
        FROM "{}"
        ORDER BY rowid DESC
        '''.format(tablename))
    result = c.fetchall()

    # We can close the connection if we are done with it.
    # Just be sure any changes have been committed or they will be lost.
    conn.close()

    return result


def evaluate_from_db(db, tablename, warn, crit, count):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    c.execute('''
        SELECT count(*)
        FROM "{}"
        WHERE tx_rate > ? or rx_rate > ?
        '''.format(tablename), (crit, crit))

    if c.fetchone()[0] == count:
        conn.close()
        return STATE_CRIT

    c.execute('''
        SELECT count(*)
        FROM "{}"
        WHERE tx_rate > ? or rx_rate > ?
        '''.format(tablename), (warn, warn))

    if c.fetchone()[0] == count:
        conn.close()
        return STATE_WARN
    
    # We can close the connection if we are done with it.
    conn.close()
    return STATE_OK


def float_or_none(input):
    if str(input) == 'None':
        return None

    return float(input)


def main():    
    # parse the command line, exit with UNKNOWN if it fails
    try:
        parsed = define_args()
    except SystemExit as e:
        exit(STATE_UNKNOWN)

    thresholds = {}
    INTERFACES = parsed.INTERFACES if parsed.INTERFACES else DEFAULT_INTERFACES
    for interface in INTERFACES:
        thresholds[interface[0]] = [float_or_none(x) for x in interface[1:]] # convert speed, warn and crit to float, then add to dictionary based on ifname

    overall_state = STATE_OK
    table_data = []
    perfdata = ''
    highest_ifname = ''
    highest_rx_rate = 0
    highest_tx_rate = 0
    unix_timestamp = int(time.time())

    network_stats = psutil.net_io_counters(pernic=True)
    for ifname in network_stats:
        if ifname == 'lo':
            continue

        if '*' not in thresholds.keys()\
        and ifname not in thresholds.keys():
            continue

        interface_state = STATE_OK
        stats_rate = {}
        stats_rate['unix_timestamp'] = unix_timestamp
        stats_drp_err = {}
        for stat in ['bytes_sent', 'bytes_recv']:
            if hasattr(network_stats[ifname], stat):
                stats_rate[stat] = int(getattr(network_stats[ifname], stat))

        for stat in ['errin', 'errout', 'dropin', 'dropout']:
            if hasattr(network_stats[ifname], stat):
                stats_drp_err[stat] = int(getattr(network_stats[ifname], stat))

        # try to get last stats
        try:
            last_rate_stats = get_from_db(DB, '{}_rate_values'.format(ifname))
            # last_rate_stats[0] = (bytes_sent, tx_rate, bytes_recv, rx_rate, unix_timestamp)
            pos_bytes_sent = 0
            pos_tx_rate = 1
            pos_bytes_recv = 2
            pos_rx_rate = 3
            pos_rate_unix_timestamp = 4

            # first try the ifname, then '*', else None
            rx_rate_speed, rx_rate_warn_pcent, rx_rate_crit_pcent = thresholds.get(ifname, thresholds.get('*', (None, None, None)))
            if rx_rate_warn_pcent:
                rx_rate_warn = rx_rate_speed * rx_rate_warn_pcent * 0.01 * 10**6 # to percent, them from mbps to bps
            else:
                rx_rate_warn = None

            if rx_rate_crit_pcent:
                rx_rate_crit = rx_rate_speed * rx_rate_crit_pcent * 0.01 * 10**6
            else:
                rx_rate_crit = None

            tx_rate_speed, tx_rate_warn_pcent, tx_rate_crit_pcent = thresholds.get(ifname, thresholds.get('*', (None, None, None)))
            if tx_rate_warn_pcent:
                tx_rate_warn = tx_rate_speed * tx_rate_warn_pcent * 0.01 * 10**6
            else:
                tx_rate_warn = None

            if tx_rate_crit_pcent:
                tx_rate_crit = tx_rate_speed * tx_rate_crit_pcent * 0.01 * 10**6
            else:
                tx_rate_crit = None

            time_delta = int(stats_rate['unix_timestamp']) - int(last_rate_stats[0][pos_rate_unix_timestamp])
            stats_rate['rx_rate'] = (stats_rate['bytes_recv'] - last_rate_stats[0][pos_bytes_recv]) / time_delta * 8 # conversion from bytes/s to bits/s
            if stats_rate['rx_rate'] < 0:
                stats_rate['rx_rate'] = 0 # handle negative numbers due to eg reboots
            perfdata += unpack_perfdata('{}_RX_Rate'.format(ifname), stats_rate['rx_rate'], None, rx_rate_warn, rx_rate_crit, 0, None)
            interface_state = get_greater_state(interface_state, evaluate_from_db(DB, '{}_rate_values'.format(ifname), rx_rate_warn, rx_rate_crit, parsed.COUNT))

            stats_rate['tx_rate'] = (stats_rate['bytes_sent'] - last_rate_stats[0][pos_bytes_sent]) / time_delta * 8 # conversion from bytes/s to bits/s
            if stats_rate['tx_rate'] < 0:
                stats['tx_rate'] = 0 # handle negative numbers due to eg reboots
            perfdata += unpack_perfdata('{}_TX_Rate'.format(ifname), stats_rate['tx_rate'], None, tx_rate_warn, tx_rate_crit, 0, None)
            interface_state = get_greater_state(interface_state, evaluate_from_db(DB, '{}_rate_values'.format(ifname), rx_rate_warn, rx_rate_crit, parsed.COUNT))

            if stats_rate['rx_rate'] >= highest_rx_rate\
            or stats_rate['rx_rate'] >= highest_tx_rate:
                highest_ifname = ifname
                highest_rx_rate = stats_rate['rx_rate']
                highest_tx_rate = stats_rate['tx_rate']

            if stats_rate['tx_rate'] >= highest_rx_rate\
            or stats_rate['tx_rate'] >= highest_tx_rate:
                highest_ifname = ifname
                highest_rx_rate = stats_rate['rx_rate']
                highest_tx_rate = stats_rate['tx_rate']

        except (sqlite3.OperationalError, IndexError) as e:
            stats_rate['tx_rate'] = 0
            stats_rate['rx_rate'] = 0

        try:
            last_drp_err_stats = get_from_db(DB, '{}_drp_err_values'.format(ifname))
            # last_drp_err_stats[0] = (errin, dropin, dropout, errout, unix_timestamp)
            pos_errin = 0
            pos_dropin = 1
            pos_dropout = 2
            pos_errout = 3
            pos_drp_err_unix_timestamp = 4

            if stats_drp_err['errin'] > last_drp_err_stats[0][pos_errin]\
            or stats_drp_err['dropin'] > last_drp_err_stats[0][pos_dropin]\
            or stats_drp_err['dropout'] > last_drp_err_stats[0][pos_dropout]\
            or stats_drp_err['errout'] > last_drp_err_stats[0][pos_errout]:
                # check if a value increased
                stats_drp_err['unix_timestamp'] = unix_timestamp
                interface_state = get_greater_state(interface_state, STATE_WARN)
            else:
                # else check if there is a timestamp in the timespan that should be notified
                if unix_timestamp - last_drp_err_stats[0][pos_drp_err_unix_timestamp] < parsed.TIMESPAN * 60:
                    stats_drp_err['unix_timestamp'] = last_drp_err_stats[0][pos_drp_err_unix_timestamp]
                    interface_state = get_greater_state(interface_state, STATE_WARN)
                else:
                    # if no other case applies, set the unix_timestamp to the last or to 0 so that the insert does not fail
                    stats_drp_err['unix_timestamp'] = last_drp_err_stats[0][pos_drp_err_unix_timestamp] if last_drp_err_stats[0][pos_drp_err_unix_timestamp] else 0

        except (sqlite3.OperationalError, IndexError) as e:
            stats_drp_err['unix_timestamp'] = 0

        table_data.append({
            'ifname': '{} {}'.format(ifname, state_to_string(interface_state)),
            'rx_rate': '{}bps'.format(bytes2human(stats_rate['rx_rate'])),
            'errin': stats_drp_err['errin'],
            'dropin': stats_drp_err['dropin'],
            'tx_rate': '{}bps'.format(bytes2human(stats_rate['tx_rate'])),
            'errout': stats_drp_err['errout'],
            'dropout': stats_drp_err['dropout'],
        })

        overall_state = get_greater_state(overall_state, interface_state)

        # save trend data to local sqlite database, limited to "count" rows max.
        insert_rate_values_into_db(DB, '{}_rate_values'.format(ifname), stats_rate, parsed.COUNT)
        insert_drp_err_values_into_db(DB, '{}_drp_err_values'.format(ifname), stats_drp_err)


    if overall_state == STATE_OK:
        msg = 'Everything is ok. {}: {}bps/{}bps (RX/TX)'.format(
            highest_ifname,
            bytes2human(highest_rx_rate),
            bytes2human(highest_tx_rate)
            )
    else:
        msg = 'One or more errors. {}: {}bps/{}bps (RX/TX)'.format(
            highest_ifname,
            bytes2human(highest_rx_rate),
            bytes2human(highest_tx_rate)
            )

    table = format_as_table(table_data, ['ifname', 'rx_rate', 'errin', 'dropin', 'dropin', 'tx_rate', 'errout', 'dropout'], ['ifname', 'rx_rate', 'errin', 'dropin', 'dropin', 'tx_rate', 'errout', 'dropout'], 'ifname')

    print(msg.strip() + '\n\n' + table + '|' + perfdata.strip())
    exit(overall_state)

if __name__ == '__main__':
    main()
