#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://nagios-plugins.org/doc/guidelines.html


__author__  = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020010901'

DESCRIPTION = 'Checks network IO.'

DEFAULT_COUNT = 5       # measurements; if check runs once per minute, this is a 5 minute interval

RX_ERR_DEFAULT_WARN = 1
RX_ERR_DEFAULT_CRIT = None

RX_DRP_DEFAULT_WARN = 1
RX_DRP_DEFAULT_CRIT = None

RX_OVRUN_DEFAULT_WARN = 1
RX_OVRUN_DEFAULT_CRIT = None

TX_ERR_DEFAULT_WARN = 1
TX_ERR_DEFAULT_CRIT = None

TX_DRP_DEFAULT_WARN = 1
TX_DRP_DEFAULT_CRIT = None

TX_COLL_DEFAULT_WARN = 1
TX_COLL_DEFAULT_CRIT = None

DEFAULT_IGNORE = ['lo']

#====================
import argparse
import sqlite3
import psutil

from lib.globals import *
from lib.utils import execute_command
from lib.output import unpack_perfdata, bytes2human, state_to_string, console_color
from lib.parse_arguments import csv_arg
from lib.parse_input import evaluate_greater


def define_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument('-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
        )

    # parser.add_argument('-w', '--warning',
    #     help = 'Set the warning threshold in bps for the RX and TX rate, in the format "1000,2000". Default: %(default)s',
    #     dest = 'WARN',
    #     type = csv_arg,
    #     default = [RX_RATE_DEFAULT_WARN,TX_RATE_DEFAULT_WARN],
    #     )

    # parser.add_argument('-c', '--critical',
    #     help = 'Set the critical threshold in bps for the RX and TX rate, in the format "1000,2000". Default: %(default)s',
    #     dest = 'CRIT',
    #     type = csv_arg,
    #     default = [RX_RATE_DEFAULT_CRIT,TX_RATE_DEFAULT_CRIT],
    #     )
    # todo: allow setting of speed, warn and crit per interface (eg `eth1,10,50,70;ifname,warn_mbps,crit_mbps)

    parser.add_argument('-i', '--ignore',
        help = 'Ignore certain interface names, in the format "lo,eno1". Default: %(default)s',
        dest = 'IGNORE',
        type = csv_arg,
        default = DEFAULT_IGNORE,
        )

    parser.add_argument('--count',
        help = 'Number of times the value has to be above the given thresholds. Default: %(default)s',
        dest = 'COUNT',
        type = int,
        default = DEFAULT_COUNT,
        )

    return parser.parse_args()


    # https://docs.python.org/2/library/sqlite3.html
    def insert_into_db(db, values, count):
        conn = sqlite3.connect(db)

        c = conn.cursor()

        # create table if it does not exist
        c.execute('''
            CREATE TABLE IF NOT EXISTS check_values (
                bytes_sent REAL NOT NULL,
                tx_rate REAL NOT NULL,
                bytes_recv REAL NOT NULL,
                rx_rate REAL NOT NULL,
                errin REAL NOT NULL,
                errout REAL NOT NULL,
                dropin REAL NOT NULL,
                dropout REAL NOT NULL
                )
            ''')

        # insert a row of data (named values from a dictionary)
        c.execute('INSERT INTO check_values VALUES (:bytes_sent, :tx_rate, :bytes_recv, :rx_rate, :errin, :errout, :dropin, :dropout)', values)

        # leave only the latest "count" records, using the sqlite built-in "rowid"
        c.execute('''
            DELETE FROM check_values
            WHERE rowid IN (
                SELECT rowid
                FROM check_values
                ORDER BY rowid DESC
                LIMIT -1
                OFFSET ?
            )
            ''', (count, ))

        # Save (commit) the changes
        conn.commit()

        # We can close the connection if we are done with it.
        # Just be sure any changes have been committed or they will be lost.
        conn.close()


    def get_from_db(db, threshold):
        conn = sqlite3.connect(db)

        c = conn.cursor()

        c.execute('''
            SELECT count(*)
            FROM check_values
            WHERE user > ? or system > ? or iowait > ? or cpu_usage > ?
            ''', (threshold, threshold, threshold, threshold))
        result = c.fetchone()

        # We can close the connection if we are done with it.
        # Just be sure any changes have been committed or they will be lost.
        conn.close()

        return result[0]


def main():    
    # parse the command line, exit with UNKNOWN if it fails
    try:
        parsed = define_args()
    except SystemExit as e:
        exit(STATE_UNKNOWN)


    stats = {}
    network_stats = psutil.net_io_counters(pernic=True)
    for interface in network_stats:
        stats[interface] = {}
        for stat in ['bytes_sent', 'bytes_recv', 'errin', 'errout', 'dropin', 'dropout']:
            if hasattr(network_stats[interface], stat):
                stats[interface][stat] = getattr(network_stats[interface], stat)

    # try to get latest data


    exit()
    # save trend data to local sqlite database, limited to "count" rows max.
    insert_into_db('/tmp/network-io.db', stats, parsed.COUNT)

    overall_state = STATE_OK

    perfdata = '' # use speed as max for grafana?

    highest_ifname = ''
    highest_rx_rate = 0
    highest_tx_rate = 0

    if latest_data:
        for ifname, values in sorted(current_data.items()):
            try: # needed to prevent key lookup errors in the latest_date dict when new interfaces appear
                interface_state = STATE_OK
                time_delta  = (current_data[ifname]['timestamp'] - latest_data[ifname]['timestamp']).total_seconds();

                perfdata += unpack_perfdata('{}_RX_Packets'.format(ifname), current_data[ifname]['RX']['bytes'], 'c', None, None, 0, None)

                rx_rate = (current_data[ifname]['RX']['bytes'] - latest_data[ifname]['RX']['bytes']) / time_delta * 8; # conversion from bytes/s to bits/s
                if rx_rate < 0:
                    rx_rate = 0 # handle negative numbers due to eg reboots
                interface_state = get_greater_state(interface_state, evaluate_greater(rx_rate, RX_RATE_WARN, RX_RATE_CRIT))
                perfdata += unpack_perfdata('{}_RX_Rate'.format(ifname), rx_rate, None, RX_RATE_WARN, RX_RATE_CRIT, 0, None)

                interface_state = get_greater_state(interface_state, evaluate_greater(values['RX']['errors'], RX_ERR_DEFAULT_WARN, RX_ERR_DEFAULT_CRIT))
                perfdata += unpack_perfdata('{}_RX_Err'.format(ifname), values['RX']['errors'], None, RX_ERR_DEFAULT_WARN, RX_ERR_DEFAULT_CRIT, 0, None)

                perfdata += unpack_perfdata('{}_RX_Drp'.format(ifname), values['RX']['dropped'], None, RX_DRP_DEFAULT_WARN, RX_DRP_DEFAULT_CRIT, 0, None)

                interface_state = get_greater_state(interface_state, evaluate_greater(values['RX']['overrun'], RX_OVRUN_DEFAULT_WARN, RX_OVRUN_DEFAULT_CRIT))
                perfdata += unpack_perfdata('{}_RX_Ovrun'.format(ifname), values['RX']['overrun'], None, RX_OVRUN_DEFAULT_WARN, RX_OVRUN_DEFAULT_CRIT, 0, None)


                perfdata += unpack_perfdata('{}_TX_Packets'.format(ifname), current_data[ifname]['TX']['bytes'], 'c', None, None, 0, None)

                tx_rate = (current_data[ifname]['TX']['bytes'] - latest_data[ifname]['TX']['bytes']) / time_delta * 8; # conversion from bytes/s to bits/s
                if tx_rate < 0:
                    tx_rate = 0 # handle negative numbers due to eg reboots
                interface_state = get_greater_state(interface_state, evaluate_greater(tx_rate, TX_RATE_WARN, TX_RATE_CRIT))
                perfdata += unpack_perfdata('{}_TX_Rate'.format(ifname), tx_rate, None, TX_RATE_WARN, TX_RATE_CRIT, 0, None)

                interface_state = get_greater_state(interface_state, evaluate_greater(values['TX']['errors'], TX_ERR_DEFAULT_WARN, TX_ERR_DEFAULT_CRIT))
                perfdata += unpack_perfdata('{}_TX_Err'.format(ifname), values['TX']['errors'], None, TX_ERR_DEFAULT_WARN, TX_ERR_DEFAULT_CRIT, 0, None)

                perfdata += unpack_perfdata('{}_TX_Drp'.format(ifname), values['TX']['dropped'], None, TX_DRP_DEFAULT_WARN, TX_DRP_DEFAULT_CRIT, 0, None)

                interface_state = get_greater_state(interface_state, evaluate_greater(values['TX']['collsns'], TX_COLL_DEFAULT_WARN, TX_COLL_DEFAULT_CRIT))
                perfdata += unpack_perfdata('{}_TX_Coll'.format(ifname), values['TX']['collsns'], None, TX_COLL_DEFAULT_WARN, TX_COLL_DEFAULT_CRIT, 0, None)

                if ifname != 'lo':
                    if rx_rate >= highest_rx_rate\
                    or rx_rate >= highest_tx_rate:
                        highest_ifname = ifname
                        highest_rx_rate = rx_rate
                        highest_tx_rate = tx_rate

                    if tx_rate >= highest_rx_rate\
                    or tx_rate >= highest_tx_rate:
                        highest_ifname = ifname
                        highest_rx_rate = rx_rate
                        highest_tx_rate = tx_rate

                overall_state = get_greater_state(overall_state, interface_state)
                
                table += '\n{:25}{:5}║{:12}{:6}{:7}{:6}║{:12}{:6}{:7}{}'.format(
                    ifname + state_to_string(interface_state), values['mtu'],
                    str(bytes2human(rx_rate)) + 'bps',
                    str(values['RX']['errors']),
                    str(values['RX']['dropped']),
                    str(values['RX']['overrun']),
                    str(bytes2human(tx_rate)) + 'bps',
                    str(values['TX']['errors']),
                    str(values['TX']['dropped']),
                    str(values['TX']['collsns'])
                    )
            except KeyError as e:
                pass # needed to prevent empty statement

        if overall_state == STATE_OK:
            msg = 'Everything is ok. {}: {}bps/{}bps (RX/TX)'.format(
                highest_ifname,
                bytes2human(highest_rx_rate),
                bytes2human(highest_tx_rate)
                )
        else:
            msg = 'One or more errors. {}: {}bps/{}bps (RX/TX)'.format(
                highest_ifname,
                bytes2human(highest_rx_rate),
                bytes2human(highest_tx_rate)
                )

    else:
        msg = 'Waiting for the latest data...'

    print(msg.strip() + '\n' + table + '|' + perfdata.strip())

    exit(overall_state)

if __name__ == '__main__':
    main()
