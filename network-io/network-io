#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://nagios-plugins.org/doc/guidelines.html


__author__  = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2019111401'

DESCRIPTION = 'Checks network IO.'

bash_command = 'ip --statistics link'

RX_RATE_DEFAULT_WARN = 8000000000 # 8 Gbps
RX_RATE_DEFAULT_CRIT = 9000000000 # 9 Gbps

TX_RATE_DEFAULT_WARN = 8000000000 # 8 Gbps
TX_RATE_DEFAULT_CRIT = 9000000000 # 9 Gbps

RX_ERR_DEFAULT_WARN = 1
RX_ERR_DEFAULT_CRIT = None

RX_DRP_DEFAULT_WARN = 1
RX_DRP_DEFAULT_CRIT = None

RX_OVRUN_DEFAULT_WARN = 1
RX_OVRUN_DEFAULT_CRIT = None

TX_ERR_DEFAULT_WARN = 1
TX_ERR_DEFAULT_CRIT = None

TX_DRP_DEFAULT_WARN = 1
TX_DRP_DEFAULT_CRIT = None

TX_COLL_DEFAULT_WARN = 1
TX_COLL_DEFAULT_CRIT = None

DEFAULT_IGNORE = []

UOM_RATE = None
UOM_PACKETS = 'c'
UOM = None
MIN = 0
MAX = None

#====================
import argparse
import cPickle as pickle
import datetime
import tempfile

from lib.globals import *
from lib.utils import execute_command
from lib.output import unpack_perfdata, bytes2human, state_to_string
from lib.parse_arguments import csv
from lib.parse_input import evaluate_greater


def define_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument('-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
        )

    parser.add_argument('-w', '--warning',
        help = 'Set the warning threshold in bps for the RX and TX rate, in the format "1000,2000". Default: %(default)s',
        dest = 'WARN',
        type = csv,
        default = [RX_RATE_DEFAULT_WARN,TX_RATE_DEFAULT_WARN],
        )

    parser.add_argument('-c', '--critical',
        help = 'Set the critical threshold in bps for the RX and TX rate, in the format "1000,2000". Default: %(default)s',
        dest = 'CRIT',
        type = csv,
        default = [RX_RATE_DEFAULT_CRIT,TX_RATE_DEFAULT_CRIT],
        )

    parser.add_argument('-i', '--ignore',
        help = 'Ignore certain interface names, in the format "lo,eno1". Default: %(default)s',
        dest = 'IGNORE',
        type = csv,
        default = DEFAULT_IGNORE,
        )

    return parser.parse_args()


def main():    
    # parse the command line, exit with UNKNOWN if it fails
    try:
        parsed = define_args()
    except SystemExit as e:
        exit(STATE_UNKNOWN)

    RX_RATE_WARN = int(parsed.WARN[0]) if parsed.WARN[0] else None
    TX_RATE_WARN = int(parsed.WARN[1]) if parsed.WARN[1] else None
    RX_RATE_CRIT = int(parsed.CRIT[0]) if parsed.CRIT[0] else None
    TX_RATE_CRIT = int(parsed.CRIT[1]) if parsed.CRIT[1] else None
    IGNORE = parsed.IGNORE if parsed.IGNORE else []

    # try to get the latest data
    try:
        latest_data = pickle.load(open('{}/network-io-dump'.format(tempfile.gettempdir()), 'rb'))        
    except:
        latest_data = None

    # execute the shell command and return its result and exit code
    stdout, stderr, retc = execute_command(bash_command)
    if (stderr or retc != 0):
        print('Bash command `{}` failed.'.format(bash_command))
        print('Stdout: {}\nStderr: {}'.format(stdout, stderr))
        exit(STATE_UNKNOWN)

    current_data = {}
    rx_labels = ['bytes', 'packets', 'errors', 'dropped', 'overrun', 'mcast']
    tx_labels = ['bytes', 'packets', 'errors', 'dropped', 'carrier', 'collsns']

    i = None
    for index, line in enumerate(stdout.splitlines()):
        if line[0].isdigit():
            ifname = line.split(': ')[1]
            if ifname not in IGNORE:
                i = index
                current_data[ifname] = {'timestamp': datetime.datetime.today(), 'mtu': line.split()[4]}

        if i is not None and index == i + 3:
            current_data[ifname]['RX'] = {}
            items = line.split()
            for item, label in zip(items, rx_labels):
                current_data[ifname]['RX'][label] = int(item)

        if i is not None and index == i + 5:
            current_data[ifname]['TX'] = {}
            items = line.split()
            for item, label in zip(items, tx_labels):
                current_data[ifname]['TX'][label] = int(item)

    pickle.dump(current_data, open('{}/network-io-dump'.format(tempfile.gettempdir()), 'wb+'))

    overall_state = STATE_OK

    perfdata = ''

    table = '''
‌‌                              ║ RX                            ║ TX
Iface                    MTU  ║ Rate       Err   Drp    Ovrun ║ Rate       Err   Drp    Coll
══════════════════════════════╬═══════════════════════════════╬══════════════════════════════'''

    highest_ifname = ''
    highest_rx_rate = 0
    highest_tx_rate = 0

    if latest_data:
        for ifname, values in sorted(current_data.items()):
            try: # needed to prevent key lookup errors in the latest_date dict when new interfaces appear
                interface_state = STATE_OK
                time_delta  = (current_data[ifname]['timestamp'] - latest_data[ifname]['timestamp']).total_seconds();

                # rx_packets_data = Data('{}_RX_Packets'.format(ifname), current_data[ifname]['RX']['bytes'], None, None)
                perfdata += unpack_perfdata('{}_RX_Packets'.format(ifname), current_data[ifname]['RX']['bytes'], 'c', None, None, 0, None)

                rx_rate = (current_data[ifname]['RX']['bytes'] - latest_data[ifname]['RX']['bytes']) / time_delta * 8; # conversion from bytes/s to bits/s
                if rx_rate < 0:
                    rx_rate = 0 # handle negative numbers due to eg reboots
                interface_state = get_greater_state(interface_state, evaluate_greater(rx_rate, RX_RATE_WARN, RX_RATE_CRIT))
                perfdata += unpack_perfdata('{}_RX_Rate'.format(ifname), rx_rate, None, RX_RATE_WARN, RX_RATE_CRIT, 0, None)

                interface_state = get_greater_state(interface_state, evaluate_greater(values['RX']['errors'], RX_ERR_DEFAULT_WARN, RX_ERR_DEFAULT_CRIT))
                perfdata += unpack_perfdata('{}_RX_Err'.format(ifname), values['RX']['errors'], None, RX_ERR_DEFAULT_WARN, RX_ERR_DEFAULT_CRIT, 0, None)

                perfdata += unpack_perfdata('{}_RX_Drp'.format(ifname), values['RX']['dropped'], None, RX_DRP_DEFAULT_WARN, RX_DRP_DEFAULT_CRIT, 0, None)

                interface_state = get_greater_state(interface_state, evaluate_greater(values['RX']['overrun'], RX_OVRUN_DEFAULT_WARN, RX_OVRUN_DEFAULT_CRIT))
                perfdata += unpack_perfdata('{}_RX_Ovrun'.format(ifname), values['RX']['overrun'], None, RX_OVRUN_DEFAULT_WARN, RX_OVRUN_DEFAULT_CRIT, 0, None)


                perfdata += unpack_perfdata('{}_TX_Packets'.format(ifname), current_data[ifname]['TX']['bytes'], 'c', None, None, 0, None)

                tx_rate = (current_data[ifname]['TX']['bytes'] - latest_data[ifname]['TX']['bytes']) / time_delta * 8; # conversion from bytes/s to bits/s
                if tx_rate < 0:
                    tx_rate = 0 # handle negative numbers due to eg reboots
                interface_state = get_greater_state(interface_state, evaluate_greater(tx_rate, TX_RATE_WARN, TX_RATE_CRIT))
                perfdata += unpack_perfdata('{}_TX_Rate'.format(ifname), tx_rate, None, TX_RATE_WARN, TX_RATE_CRIT, 0, None)

                interface_state = get_greater_state(interface_state, evaluate_greater(values['TX']['errors'], TX_ERR_DEFAULT_WARN, TX_ERR_DEFAULT_CRIT))
                perfdata += unpack_perfdata('{}_TX_Err'.format(ifname), values['TX']['errors'], None, TX_ERR_DEFAULT_WARN, TX_ERR_DEFAULT_CRIT, 0, None)

                perfdata += unpack_perfdata('{}_TX_Drp'.format(ifname), values['TX']['dropped'], None, TX_DRP_DEFAULT_WARN, TX_DRP_DEFAULT_CRIT, 0, None)

                interface_state = get_greater_state(interface_state, evaluate_greater(values['TX']['collsns'], TX_COLL_DEFAULT_WARN, TX_COLL_DEFAULT_CRIT))
                perfdata += unpack_perfdata('{}_TX_Coll'.format(ifname), values['TX']['collsns'], None, TX_COLL_DEFAULT_WARN, TX_COLL_DEFAULT_CRIT, 0, None)

                if ifname != 'lo':
                    if rx_rate >= highest_rx_rate\
                    or rx_rate >= highest_tx_rate:
                        highest_ifname = ifname
                        highest_rx_rate = rx_rate
                        highest_tx_rate = tx_rate

                    if tx_rate >= highest_rx_rate\
                    or tx_rate >= highest_tx_rate:
                        highest_ifname = ifname
                        highest_rx_rate = rx_rate
                        highest_tx_rate = tx_rate

                overall_state = get_greater_state(overall_state, interface_state)
                
                table += '\n{:25}{:5}║{:12}{:6}{:7}{:6}║{:12}{:6}{:7}{}'.format(
                    ifname + state_to_string(interface_state), values['mtu'],
                    str(bytes2human(rx_rate)) + 'bps',
                    str(values['RX']['errors']),
                    str(values['RX']['dropped']),
                    str(values['RX']['overrun']),
                    str(bytes2human(tx_rate)) + 'bps',
                    str(values['TX']['errors']),
                    str(values['TX']['dropped']),
                    str(values['TX']['collsns'])
                    )
            except KeyError as e:
                pass # needed to prevent empty statement

        if overall_state == STATE_OK:
            msg = 'Everything is ok. {}: {}bps/{}bps (RX/TX)'.format(
                highest_ifname,
                bytes2human(highest_rx_rate),
                bytes2human(highest_tx_rate)
                )
        else:
            msg = 'One or more errors. {}: {}bps/{}bps (RX/TX)'.format(
                highest_ifname,
                bytes2human(highest_rx_rate),
                bytes2human(highest_tx_rate)
                )

    else:
        msg = 'Waiting for the latest data...'

    print(msg.strip() + '\n' + table + '|' + perfdata.strip())

    exit(overall_state)

if __name__ == '__main__':
    main()
