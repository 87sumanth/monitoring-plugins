#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

import argparse
import sys
from traceback import print_exc

from lib.globals import STATE_OK, STATE_UNKNOWN, STATE_WARN

import lib.base
import lib.cache
import lib.feedparser
import lib.icinga


__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020051402'

DESCRIPTION = '''Warns on the newest feed item of an RSS or Atom feed. Does not warn any longer
    if you acknowledge it in Icingaweb2, and/or if a given amount of time is over.'''

DEFAULT_FEED_URL = 'https://www.heise.de/security/rss/alert-news-atom.xml'
DEFAULT_INSECURE = False
DEFAULT_NO_ICINGA_CALLBACK = True
DEFAULT_NO_PROXY = False
DEFAULT_NO_SUMMARY = False
DEFAULT_TIMEOUT = 5
DEFAULT_WARN = 4320     # = minutes (3 days)


def parse_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
        )

    parser.add_argument(
        '--always-ok',
        help='Always returns OK.',
        dest='ALWAYS_OK',
        action='store_true',
        default=False,
        )

    parser.add_argument(
        '--icinga-service-name',
        help='Unique name of the service using this check within Icinga. Take it from the `__name` service attribute, for example `icinga-server!my-service-name`.',
        dest='ICINGA_SERVICE_NAME',
        )

    parser.add_argument(
        '--icinga-password',
        help='Icinga API password.',
        dest='ICINGA_PASSWORD',
        )

    parser.add_argument(
        '--icinga-url',
        help='Icinga API URL, for example https://icinga-server:5665',
        dest='ICINGA_URL',
        )

    parser.add_argument(
        '--icinga-username',
        help='Icinga API username.',
        dest='ICINGA_USERNAME',
        )

    parser.add_argument(
        '--insecure',
        help='This option explicitly allows to perform "insecure" SSL connections. Default: %(default)s',
        dest='INSECURE',
        action='store_true',
        default=DEFAULT_INSECURE,
        )

    parser.add_argument(
        '--no-icinga-callback',
        help='Do not get the service acknowledgement from Icinga. Default: %(default)s',
        dest='NO_ICINGA_CALLBACK',
        action='store_false',
        default=DEFAULT_NO_ICINGA_CALLBACK,   # True
        )

    parser.add_argument(
        '--no-proxy',
        help='Do not use a proxy. Default: %(default)s',
        dest='NO_PROXY',
        action='store_true',
        default=DEFAULT_NO_PROXY,
        )

    parser.add_argument(
        '--no-summary',
        help='Do not show the feed item summary. Default: %(default)s',
        dest='NO_SUMMARY',
        action='store_true',
        default=DEFAULT_NO_SUMMARY,   # False
        )

    parser.add_argument(
        '--timeout',
        help='Network timeout in seconds. Default: %(default)s (seconds)',
        dest='TIMEOUT',
        type=int,
        default=DEFAULT_TIMEOUT,
        )

    parser.add_argument(
        '--url',
        help='The Feed URL. Default: %(default)s',
        dest='FEED_URL',
        default=DEFAULT_FEED_URL,
        )

    parser.add_argument(
        '-w', '--warning',
        help='How long should this check return a warning on new entries? Default: %(default)s (minutes)',
        dest='WARN',
        type=int,
        default=DEFAULT_WARN,
        )

    return parser.parse_args()


def fetch_feed_last_item(feed_url, insecure=False, no_proxy=False, timeout=5):
    success, myfeed = lib.feedparser.parse(
        feed_url, insecure=insecure, no_proxy=no_proxy, timeout=timeout)
    if not success:
        return (False, myfeed)
    if len(myfeed['entries']) == 0:
        return (True, [])
    return (True, myfeed['entries'][0])


def get_feed_state(feed_id, delta, args):
    """
    age of feed-item within warning period?
    yes:
        is item in cache (is it the same as from the last fetch)?
        yes:
            value from cache == already acked?
            yes:
                return STATE_OK
            is it acknowledged in icinga? (ack could have been removed in the meantime)
            yes:
                save feed-item-id to cache, value = acked, do not change expire time
                return STATE_OK
            return STATE_WARN
        no:
            save feed-item-id to cache, value = '', expire time = now + args.WARN minutes
            return STATE_WARN
    no:
        return STATE_OK (feed item is not of interest any more)
    """

    if delta < args.WARN*60:
        if args.NO_ICINGA_CALLBACK:
            return STATE_WARN
        cached_item = lib.cache.get('feed-{}'.format(feed_id), as_dict=True)
        if cached_item:
            if cached_item['value'] == 'acked':
                return STATE_OK
            success, icinga = lib.icinga.get_service(
                args.ICINGA_URL,
                args.ICINGA_USERNAME,
                args.ICINGA_PASSWORD,
                servicename=args.ICINGA_SERVICE_NAME,
                attrs='state,acknowledgement'
                )
            if not success:
                return STATE_WARN
            if icinga['results'][0]['attrs']['acknowledgement']:
                lib.cache.set('feed-{}'.format(feed_id), 'acked', cached_item['timestamp'])
                return STATE_OK
            else:
                return STATE_WARN
        else:
            lib.cache.set('feed-{}'.format(feed_id), 'unacked', lib.base.now() + args.WARN*60)
            return STATE_WARN
    else:
        return STATE_OK


def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit as e:
        sys.exit(STATE_UNKNOWN)

    # get the newest/latest feed item
    feed_item = lib.base.coe(fetch_feed_last_item(args.FEED_URL, args.INSECURE, args.NO_PROXY, args.TIMEOUT))

    # feed with 0 entries
    if not feed_item:
        lib.base.oao('No news are good news.', STATE_OK)

    delta = abs(lib.base.now(as_type='datetime') - feed_item.get('updated_parsed', lib.base.now(as_type='datetime')))
    delta = delta.total_seconds()   # this is the age of the newest feed item, in seconds

    state = get_feed_state(feed_item['id'], delta, args)

    if args.NO_SUMMARY:
        msg = '{} ({} ago)'.format(
            feed_item.get('title', 'No title').encode('utf-8').strip(),
            lib.base.seconds2human(delta)
        )
    else:
        msg = '{}. {} ({} ago)'.format(
            feed_item.get('title', 'No title').encode('utf-8').strip(),
            feed_item.get('summary', 'No summary').encode('utf-8').strip(),
            lib.base.seconds2human(delta)
        )

    lib.base.oao(msg, state, always_ok=args.ALWAYS_OK)


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print_exc()
        sys.exit(STATE_UNKNOWN)
