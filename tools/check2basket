#!/usr/bin/env python3
# -*- coding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

import argparse
import importlib
import json
import os
import re
import sys
import uuid

try:
    import colorama
    colorama.init(autoreset=True)
except ImportError:
    colorama = False

__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2021083001'

DESCRIPTION = 'A tool to generate icinga director baskets from a check plugin.'

skip_plugins = [
    'example',
    'dummy',
]

skip_params = [
    '--test'
]

# case does not matter, the regex uses the ignorecase option
capitalized_words = [
    'OK',
    'URL',
    'XA',
    'GC',
    'TCP',
    'MD5',
    'SHA',
    'AES',
    'DES',
    'CPU',
    'DNS',
]

command_field_id = 1

def parse_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V',
        '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__),
    )

    parser.add_argument(
        '--output-file',
        help='Set the output file. This does not work with --auto.',
        dest='OUTPUT_FILE',
        type=str,
    )

    parser.add_argument(
        '--plugin-file',
        help='Set the plugin file. Use this if you want to generate the basket for only one plugin.',
        dest='PLUGIN_FILE',
        type=str,
    )

    parser.add_argument(
        '--auto',
        help='Automatically generate a basket for each plugin.',
        dest='AUTO',
        action='store_true',
        default=False,
    )

    return parser.parse_args()


def save_json_to_file(data, filename):
    try:
        with open(filename, 'w') as file:
            json.dump(data, file, sort_keys=False, indent=4, separators=(',', ': '))
    except FileNotFoundError as e:
        err_print(f'{e}. Ignoring...')


def find_long_param(params):
    for param in params:
        if param.startswith('--'):
            return param


def get_varname(check, param):
    param = param.lstrip("-")
    return f'{check}_{param}'.replace('-', '_')


def help2description(help_text):
    return re.sub(r' Default: %\(default\)s.*$', '', help_text)


def lf_title(string):
    string = string.title()
    for item in capitalized_words:
        string = re.sub(rf'\b{item}\b', item.upper(), string, flags=re.IGNORECASE)
    return string


def get_caption(check, long_param):
    return lf_title(f'{check.replace("-", " ")}: {long_param.lstrip("-").replace("-", " ")}')


def get_visibility(varname):
    hide_if_present = [
        'password',
    ]
    if any(hide_if_present_string in varname for hide_if_present_string in hide_if_present):
        return 'hidden'
    return 'visible'


def _return_parser(self):
    return self


def warn_print(msg):
    if colorama:
        print(colorama.Fore.YELLOW + str(msg))
    else:
        print(msg)


def err_print(msg):
    if colorama:
        print(colorama.Fore.RED + str(msg))
    else:
        print(msg)


def get_plugin_args(plugin_file):
    check3 = os.path.basename(plugin_file)

    # Overwrite the parse_args() function that we usually call in our checks to simply return the parser
    argparse.ArgumentParser.parse_args = _return_parser

    spec = importlib.util.spec_from_loader(check3, importlib.machinery.SourceFileLoader(check3, plugin_file))
    plugin_module = importlib.util.module_from_spec(spec)

    try:
        spec.loader.exec_module(plugin_module)
    except Exception as e:
        err_print(f'Exception during check execution: {e}')
        return None
    except SystemExit as e:
        err_print(f'SystemExit during check execution: {e}')
        return None

    return plugin_module.parse_args()


def get_data_template():
    return {
        "Command": {
        },
        "ServiceTemplate": {
        },
        "DataList": {
        },
        "Datafield": {
        },
    }


def get_command_template(check):
    return {
        "arguments": {
        },
        "command": f"/usr/lib64/nagios/plugins/{check}",
        "disabled": False,
        "fields": [
        ],
        "imports": [],
        "is_string": None,
        "methods_execute": "PluginCheck",
        "object_name": f"cmd-check-{check}",
        "object_type": "object",
        "timeout": "10",
        "vars": {},
        "zone": None
    }


def get_service_template(check, description):
    return {
        "action_url": None,
        "apply_for": None,
        "assign_filter": None,
        "check_command": f"cmd-check-{check}",
        "check_interval": None,
        "check_period": None,
        "check_timeout": None,
        "command_endpoint": None,
        "disabled": False,
        "display_name": None,
        "enable_active_checks": None,
        "enable_event_handler": None,
        "enable_flapping": None,
        "enable_notifications": None,
        "enable_passive_checks": None,
        "enable_perfdata": None,
        "event_command": None,
        "fields": [],
        "flapping_threshold_high": None,
        "flapping_threshold_low": None,
        "groups": [],
        "host": None,
        "icon_image": f"{check}.png",
        "icon_image_alt": None,
        "imports": [
            "tpl-service-generic"
        ],
        "max_check_attempts": None,
        "notes": f"{description}",
        "notes_url": f"https://git.linuxfabrik.ch/linuxfabrik/monitoring-plugins/-/tree/master/check-plugins/{check}",
        "object_name": f"tpl-service-{check}",
        "object_type": "template",
        "retry_interval": None,
        "service_set": None,
        "template_choice": None,
        "use_agent": None,
        "use_var_overrides": None,
        "vars": {
        },
        "volatile": None,
        "zone": None
    }


def offer_selection(options):
    options = list(options)
    for index, text in enumerate(options):
        print('{}: {}'.format(index, text))

    print('n: treat as a new object and generate a new guid')

    print('- ' * 40)
    try:
        while True:
            selection = input('Please choose the corresponding object, or type "n" to generate a new guid: ')
            if selection == 'n':
                return None
            elif int(selection) < len(options):
                return options[int(selection)]
    except KeyboardInterrupt:
        sys.exit()
    except ValueError:
        print('Failed to parse selection.')
        sys.exit(3)


def manage_uuids(data, old_data=None):
    if old_data:
        reused_guid_objects = []
        for parent_key, parent_value in old_data.items():
            if parent_key == 'Datafield':
                varnames = {value['varname']: key for key, value in data['Datafield'].items()}
                for key, value in parent_value.items():
                    if 'guid' in value:
                        varname = value['varname']
                        if varname in varnames:
                            data[parent_key][varnames[varname]]['guid'] = value['guid']
                        else:
                            print(f'\nCould not find the corresponding object for "[{parent_key}][{value["varname"]}]".')
                            selection = offer_selection(varnames.keys())
                            if selection:
                                data[parent_key][varnames[selection]]['guid'] = value['guid']
                        reused_guid_objects.append(f'[{parent_key}][{value["varname"]}]')

            else:
                for key, value in parent_value.items():
                    if 'guid' in value:
                        if parent_key in data and key in data[parent_key]:
                            data[parent_key][key]['guid'] = value['guid']
                        else:
                            print(f'\nCould not find the corresponding object for "[{parent_key}][{key}]".')
                            selection = offer_selection(data[parent_key].keys())
                            if selection:
                                data[parent_key][selection]['guid'] = value['guid']
                        reused_guid_objects.append(f'[{parent_key}][{key}]')

        if reused_guid_objects:
            print('\nFound the same object in the old basket, reusing the guid:\n* ', end='')
            print('\n* '.join(reused_guid_objects))

        warn_print('\nPlease make sure the generated guid mappings are correct using "git diff".')

    new_guid_objects = []
    for parent_key, parent_value in data.items():
        for key, value in parent_value.items():
            if 'guid' not in value:
                if parent_key == 'Datafield':
                    new_guid_objects.append(f'[{parent_key}][{value["varname"]}]')
                else:
                    new_guid_objects.append(f'[{parent_key}][{key}]')
                data[parent_key][key]['guid'] = str(uuid.uuid4())

    if new_guid_objects:
        print('\nAdding guid to the following items (this means we are assuming they are new):\n* ', end='')
        print('\n* '.join(new_guid_objects))

    return data


def generate_basket(plugin_file, old_data=None):
    global command_field_id # this prevents command_field_id collisions

    plugin_args = get_plugin_args(plugin_file)

    check = os.path.basename(plugin_file).removesuffix('3')

    data = get_data_template()
    data["Command"][f"cmd-check-{check}"] = get_command_template(check)
    data["ServiceTemplate"][f"tpl-service-{check}"] = get_service_template(check, plugin_args.description)


    # handle argparse arguments

    # argparse action classes
    # class BooleanOptionalAction(Action):
    # class _StoreAction(Action):
    # class _StoreConstAction(Action):
    # class _AppendAction(Action):
    # class _AppendConstAction(Action):
    # class _CountAction(Action):
    # class _HelpAction(Action):
    # class _VersionAction(Action):
    # class _SubParsersAction(Action):
    #     class _ChoicesPseudoAction(Action):

    for action in plugin_args._actions:
        long_param = find_long_param(action.option_strings)
        if not long_param:
            warn_print(f'Could not find a long parameter for:\n{action}')
            continue
        if long_param in skip_params:
            continue
        varname = get_varname(check, long_param)

        if isinstance(action, argparse._VersionAction):
            continue

        if isinstance(action, argparse._HelpAction):
            continue

        if isinstance(action, argparse._StoreAction) or isinstance(action, argparse._AppendAction):
            data['Command'][f"cmd-check-{check}"]['arguments'][long_param] = {
                "value": f"${varname}$"
            }
            if isinstance(action, argparse._AppendAction):
                data['Command'][f"cmd-check-{check}"]['arguments'][long_param]['repeat_key'] = True

            data['Command'][f"cmd-check-{check}"]['fields'].append({
                "datafield_id": command_field_id,
                "is_required": 'y' if action.required else 'n',
                "var_filter": None
            })

            if action.choices is not None:
                datalist_name = f'{varname}_list'
                data['Datafield'][str(command_field_id)] = {
                    "varname": varname,
                    "caption": get_caption(check, long_param),
                    "description": help2description(action.help),
                    "datatype": r"Icinga\Module\Director\DataType\DataTypeDatalist",
                    "format": None,
                    "settings": {
                        "behavior": "strict",
                        "data_type": "string",
                        "datalist": datalist_name
                    }
                }

                data['DataList'][datalist_name] = {
                    "list_name": datalist_name,
                    "owner": "icinga-admin",
                    "entries": [
                    ]
                }
                for choice in action.choices:
                    data['DataList'][datalist_name]['entries'].append(
                        {
                            "entry_name": choice,
                            "entry_value": lf_title(choice.replace("-", " ").replace("_", " ")),
                            "format": "string",
                            "allowed_roles": None
                        }
                    )
            elif isinstance(action, argparse._AppendAction):
                data['Datafield'][str(command_field_id)] = {
                    "varname": varname,
                    "caption": get_caption(check, long_param),
                    "description": help2description(action.help),
                    "datatype": r"Icinga\Module\Director\DataType\DataTypeArray",
                    "format": None,
                    "settings": {
                        "visibility": get_visibility(varname)
                    }
                }
            else:
                data['Datafield'][str(command_field_id)] = {
                    "varname": varname,
                    "caption": get_caption(check, long_param),
                    "description": help2description(action.help),
                    "datatype": r"Icinga\Module\Director\DataType\DataTypeString",
                    "format": None,
                    "settings": {
                        "visibility": get_visibility(varname)
                    }
                }

            if action.default is not None:
                data['ServiceTemplate'][f"tpl-service-{check}"]['vars'][varname] = str(action.default).replace('$', '$$')

            command_field_id += 1
            continue

        if isinstance(action, argparse._StoreTrueAction):
            data['Command'][f"cmd-check-{check}"]['arguments'][f'{long_param}'] = {
                "set_if": f"${get_varname(check, long_param)}$"
            }

            data['Command'][f"cmd-check-{check}"]['fields'].append({
                "datafield_id": command_field_id,
                "is_required": "n",
                "var_filter": None
            })

            data['Datafield'][str(command_field_id)] = {
                "varname": varname,
                "caption": get_caption(check, long_param) + '?',
                "description": help2description(action.help),
                "datatype": r"Icinga\Module\Director\DataType\DataTypeBoolean",
                "format": None,
                "settings": {}
            }

            if action.default is not None:
                data['ServiceTemplate'][f"tpl-service-{check}"]['vars'][varname] = action.default

            command_field_id += 1
            continue

        warn_print(f'Unhandled action class: "{action.__class__.__name__}".')

    return manage_uuids(data, old_data)


def main():
    args = parse_args()

    if args.PLUGIN_FILE and args.OUTPUT_FILE:
        old_data = None
        if os.path.isfile(args.OUTPUT_FILE):
            with open(args.OUTPUT_FILE, 'rb') as file:
                print(f'Found an existing basket at {args.OUTPUT_FILE}, updating it.')
                old_data = json.load(file)
        save_json_to_file(generate_basket(args.PLUGIN_FILE, old_data), args.OUTPUT_FILE)

    elif args.AUTO:
        directories = os.listdir('check-plugins')
        for directory in directories:
            if directory in skip_plugins:
                continue

            plugin_file = os.path.join('check-plugins', directory, directory + '3')
            if os.path.isfile(plugin_file):
                print(f'Check: {directory}')
                old_data = None
                output_file = os.path.join('check-plugins', directory, 'icingaweb2-module-director', f'{directory}.json')
                if os.path.isfile(output_file):
                    with open(output_file, 'rb') as file:
                        print(f'Found an existing basket at {output_file}, updating it.')
                        old_data = json.load(file)
                else:
                    try:
                        os.mkdir(os.path.join('check-plugins', directory, 'icingaweb2-module-director'))
                    except FileExistsError:
                        pass

                plugin_data = generate_basket(plugin_file, old_data)
                if plugin_data:
                    save_json_to_file(plugin_data, output_file)
                else:
                    err_print(f'No data for {directory}.')

    else:
        err_print('Either --auto or --plugin-file and --output-file is required.')
        sys.exit(2)


if __name__ == '__main__':
    main()
