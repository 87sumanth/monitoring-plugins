#!/usr/bin/env python3
# -*- coding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

import argparse
import importlib
import json
import os
import re
import sys
import uuid
import yaml

try:
    import colorama
    colorama.init(autoreset=True)
except ImportError:
    colorama = False

__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2021090101'

DESCRIPTION = 'A tool to generate icinga director baskets from a check plugin.'

DEFAULT_VARIANTS = [
    'linux',
]


skip_plugins = [
    'example',
    'dummy',
]

skip_params = [
    '--test'
]

# case does not matter, the regex uses the ignorecase option
capitalized_words = [
    'AES',
    'CPU',
    'DES',
    'DNS',
    'FQDN',
    'FS',
    'GC',
    'MD5',
    'NTP',
    'OK',
    'PHP',
    'SHA',
    'TCP',
    'TCP6',
    'UDP',
    'UDP6',
    'URL',
    'XA',
]

command_field_id = 1

def parse_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V',
        '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__),
    )

    parser.add_argument(
        '--plugin-file',
        help='Set the plugin file. Use this if you want to generate the basket for only one plugin.',
        dest='PLUGIN_FILE',
        type=str,
    )

    parser.add_argument(
        '--auto',
        help='Automatically generate a basket for each plugin.',
        dest='AUTO',
        action='store_true',
        default=False,
    )

    return parser.parse_args()


def save_json_to_file(data, filename):
    try:
        with open(filename, 'w') as file:
            json.dump(data, file, sort_keys=False, indent=4, separators=(',', ': '))
    except FileNotFoundError as e:
        err_print(f'{e}. Ignoring...')


def find_long_param(params):
    for param in params:
        if param.startswith('--'):
            return param


def get_varname(check, param):
    param = param.lstrip("-")
    return f'{check}_{param}'.replace('-', '_')


def help2description(help_text):
    return re.sub(r' Default: %\(default\)s.*$', '', help_text)


def lf_title(string):
    string = string.title()
    for item in capitalized_words:
        string = re.sub(rf'\b{item}\b', item.upper(), string, flags=re.IGNORECASE)
    return string


def get_caption(check, long_param):
    return lf_title(f'{check.replace("-", " ")}: {long_param.lstrip("-").replace("-", " ")}')


def get_visibility(varname):
    hide_if_present = [
        'password',
    ]
    if any(hide_if_present_string in varname for hide_if_present_string in hide_if_present):
        return 'hidden'
    return 'visible'


def _return_parser(self):
    return self


def warn_print(msg):
    if colorama:
        print(colorama.Fore.YELLOW + str(msg))
    else:
        print(msg)


def err_print(msg):
    if colorama:
        print(colorama.Fore.RED + str(msg))
    else:
        print(msg)


def get_plugin_args(plugin_file):
    check3 = os.path.basename(plugin_file)

    # Overwrite the parse_args() function that we usually call in our checks to simply return the parser
    argparse.ArgumentParser.parse_args = _return_parser

    spec = importlib.util.spec_from_loader(check3, importlib.machinery.SourceFileLoader(check3, plugin_file))
    plugin_module = importlib.util.module_from_spec(spec)

    try:
        spec.loader.exec_module(plugin_module)
    except Exception as e:
        err_print(f'Exception during check execution: {e}')
        return None
    except SystemExit as e:
        err_print(f'SystemExit during check execution: {e}')
        return None

    return plugin_module.parse_args()


def get_data_template():
    return {
        "Command": {
        },
        "ServiceTemplate": {
        },
        "DataList": {
        },
        "Datafield": {
        },
    }


def get_command_template(data, object_name, command, imports=None):
    if imports is None:
        data["Command"][object_name] = {
            "arguments": {
            },
            "command": command,
            "disabled": False,
            "fields": [],
            "imports": [],
            "is_string": None,
            "methods_execute": "PluginCheck",
            "object_name": object_name,
            "object_type": "object",
            "timeout": "10",
            "vars": {},
            "zone": None
        }
    else:
        # only set the required options, the rest will be done by the import
        data["Command"][object_name] = {
            "arguments": {
            },
            "command": command,
            "disabled": False,
            "fields": [],
            "imports": imports,
            "is_string": None,
            "methods_execute": "PluginCheck",
            "object_name": object_name,
            "object_type": "object",
            "timeout": None,
            "vars": {},
            "zone": None
        }
    return data


def get_service_template(data, object_name, check_command, check_name, description, imports=None):
    if imports is None:
        data["ServiceTemplate"][object_name] = {
            "action_url": None,
            "apply_for": None,
            "assign_filter": None,
            "check_command": check_command,
            "check_interval": 60,
            "check_period": None,
            "check_timeout": None,
            "command_endpoint": None,
            "disabled": False,
            "display_name": None,
            "enable_active_checks": None,
            "enable_event_handler": None,
            "enable_flapping": None,
            "enable_notifications": None,
            "enable_passive_checks": None,
            "enable_perfdata": None,
            "event_command": None,
            "fields": [],
            "flapping_threshold_high": None,
            "flapping_threshold_low": None,
            "groups": [],
            "host": None,
            "icon_image": f"{check_name}.png",
            "icon_image_alt": None,
            "imports": [
                "tpl-service-generic"
            ],
            "max_check_attempts": 5,
            "notes": f"{description}",
            "notes_url": f"https://git.linuxfabrik.ch/linuxfabrik/monitoring-plugins/-/tree/master/check-plugins/{check_name}",
            "object_name": object_name,
            "object_type": "template",
            "retry_interval": 15,
            "service_set": None,
            "template_choice": None,
            "use_agent": None,
            "use_var_overrides": None,
            "vars": {},
            "volatile": None,
            "zone": None
        }
    else:
        # only set the required options, the rest will be done by the import
        data["ServiceTemplate"][object_name] = {
            "action_url": None,
            "apply_for": None,
            "assign_filter": None,
            "check_command": check_command,
            "check_interval": None,
            "check_period": None,
            "check_timeout": None,
            "command_endpoint": None,
            "disabled": False,
            "display_name": None,
            "enable_active_checks": None,
            "enable_event_handler": None,
            "enable_flapping": None,
            "enable_notifications": None,
            "enable_passive_checks": None,
            "enable_perfdata": None,
            "event_command": None,
            "fields": [],
            "flapping_threshold_high": None,
            "flapping_threshold_low": None,
            "groups": [],
            "host": None,
            "icon_image": None,
            "icon_image_alt": None,
            "imports": imports,
            "max_check_attempts": None,
            "notes": None,
            "notes_url": None,
            "object_name": object_name,
            "object_type": "template",
            "retry_interval": None,
            "service_set": None,
            "template_choice": None,
            "use_agent": False,
            "use_var_overrides": None,
            "vars": {},
            "volatile": None,
            "zone": None
        }
    return data


def offer_selection(options):
    options = list(options)
    for index, text in enumerate(options):
        print('{}: {}'.format(index, text))

    print('n: treat as a new object and generate a new guid')

    print('- ' * 40)
    try:
        while True:
            selection = input('Please choose the corresponding object, or type "n" to generate a new guid: ')
            if selection == 'n':
                return None
            elif int(selection) < len(options):
                return options[int(selection)]
    except KeyboardInterrupt:
        sys.exit()
    except ValueError:
        print('Failed to parse selection.')
        sys.exit(3)


def manage_uuids(data, old_data=None):
    if old_data:
        # TODO: turn around the logic, iterate data and search for corresponding objects in old_data.
        # because currently it offers an selection for deleted objects, which is not needed
        reused_guid_objects = []
        for parent_key, parent_value in old_data.items():
            if parent_key == 'Datafield':
                varnames = {value['varname']: key for key, value in data['Datafield'].items()}
                for key, value in parent_value.items():
                    if 'guid' in value:
                        varname = value['varname']
                        if varname in varnames:
                            data[parent_key][varnames[varname]]['guid'] = value['guid']
                        else:
                            print(f'\nCould not find the corresponding object for "[{parent_key}][{value["varname"]}]".')
                            selection = offer_selection(varnames.keys())
                            if selection:
                                data[parent_key][varnames[selection]]['guid'] = value['guid']
                        reused_guid_objects.append(f'[{parent_key}][{value["varname"]}]')

            else:
                for key, value in parent_value.items():
                    if 'guid' in value:
                        if parent_key in data and key in data[parent_key]:
                            data[parent_key][key]['guid'] = value['guid']
                        else:
                            print(f'\nCould not find the corresponding object for "[{parent_key}][{key}]".')
                            selection = offer_selection(data[parent_key].keys())
                            if selection:
                                data[parent_key][selection]['guid'] = value['guid']
                        reused_guid_objects.append(f'[{parent_key}][{key}]')

        if reused_guid_objects:
            print('\nFound an object with the same name in the old basket, reusing the guid:\n* ', end='')
            print('\n* '.join(reused_guid_objects))

        warn_print('\nPlease make sure the generated guid mappings are correct using "git diff".')

    new_guid_objects = []
    for parent_key, parent_value in data.items():
        for key, value in parent_value.items():
            if 'guid' not in value:
                if parent_key == 'Datafield':
                    new_guid_objects.append(f'[{parent_key}][{value["varname"]}]')
                else:
                    new_guid_objects.append(f'[{parent_key}][{key}]')
                data[parent_key][key]['guid'] = str(uuid.uuid4())

    if new_guid_objects:
        print('\nAdding guid to the following items (this means we are assuming they are new):\n* ', end='')
        print('\n* '.join(new_guid_objects))

    return data


def apply_overwrites(data, overwrites):
    for key, value in overwrites.items():
        try:
            exec(f'data{key} = value', {}, {'value': value, 'data': data})
        except KeyError:
            err_print(f'Could not apply overwrite "{key}", as the path was not found. Continuing...')

    return data


def parse_plugin_args(data, plugin_args, check_name, command_object_name, service_object_name, varname_suffix=''):
    global command_field_id # this prevents command_field_id collisions

    # argparse action classes
    # class BooleanOptionalAction(Action):
    # class _StoreAction(Action):
    # class _StoreConstAction(Action):
    # class _AppendAction(Action):
    # class _AppendConstAction(Action):
    # class _CountAction(Action):
    # class _HelpAction(Action):
    # class _VersionAction(Action):
    # class _SubParsersAction(Action):
    #     class _ChoicesPseudoAction(Action):

    for action in plugin_args._actions:
        long_param = find_long_param(action.option_strings)
        if not long_param:
            warn_print(f'Could not find a long parameter for:\n{action}')
            continue
        if long_param in skip_params:
            continue
        varname = get_varname(check_name + varname_suffix, long_param)

        if isinstance(action, argparse._VersionAction):
            continue

        if isinstance(action, argparse._HelpAction):
            continue

        if isinstance(action, argparse._StoreAction) or isinstance(action, argparse._AppendAction):
            data['Command'][command_object_name]['arguments'][long_param] = {
                "value": f"${varname}$"
            }
            if isinstance(action, argparse._AppendAction):
                data['Command'][command_object_name]['arguments'][long_param]['repeat_key'] = True

            data['Command'][command_object_name]['fields'].append({
                "datafield_id": command_field_id,
                "is_required": 'y' if action.required else 'n',
                "var_filter": None
            })

            if action.choices is not None:
                datalist_name = f'{varname}_list'
                data['Datafield'][str(command_field_id)] = {
                    "varname": varname,
                    "caption": get_caption(check_name, long_param),
                    "description": help2description(action.help),
                    "datatype": r"Icinga\Module\Director\DataType\DataTypeDatalist",
                    "format": None,
                    "settings": {
                        "behavior": "strict",
                        "data_type": "string",
                        "datalist": datalist_name
                    }
                }

                data['DataList'][datalist_name] = {
                    "list_name": datalist_name,
                    "owner": "icinga-admin",
                    "entries": [
                    ]
                }
                for choice in action.choices:
                    data['DataList'][datalist_name]['entries'].append(
                        {
                            "entry_name": choice,
                            "entry_value": lf_title(choice.replace("-", " ").replace("_", " ")),
                            "format": "string",
                            "allowed_roles": None
                        }
                    )
            elif isinstance(action, argparse._AppendAction):
                data['Datafield'][str(command_field_id)] = {
                    "varname": varname,
                    "caption": get_caption(check_name, long_param),
                    "description": help2description(action.help),
                    "datatype": r"Icinga\Module\Director\DataType\DataTypeArray",
                    "format": None,
                    "settings": {
                        "visibility": get_visibility(varname)
                    }
                }
            else:
                data['Datafield'][str(command_field_id)] = {
                    "varname": varname,
                    "caption": get_caption(check_name, long_param),
                    "description": help2description(action.help),
                    "datatype": r"Icinga\Module\Director\DataType\DataTypeString",
                    "format": None,
                    "settings": {
                        "visibility": get_visibility(varname)
                    }
                }

            if action.default is not None:
                data['ServiceTemplate'][service_object_name]['vars'][varname] = str(action.default).replace('$', '$$')

            command_field_id += 1
            continue

        if isinstance(action, argparse._StoreTrueAction):
            data['Command'][command_object_name]['arguments'][f'{long_param}'] = {
                "set_if": f"${get_varname(check_name + varname_suffix, long_param)}$"
            }

            data['Command'][command_object_name]['fields'].append({
                "datafield_id": command_field_id,
                "is_required": "n",
                "var_filter": None
            })

            data['Datafield'][str(command_field_id)] = {
                "varname": varname,
                "caption": get_caption(check_name, long_param) + '?',
                "description": help2description(action.help),
                "datatype": r"Icinga\Module\Director\DataType\DataTypeBoolean",
                "format": None,
                "settings": {}
            }

            if action.default is not None:
                data['ServiceTemplate'][service_object_name]['vars'][varname] = action.default

            command_field_id += 1
            continue

        warn_print(f'Unhandled action class: "{action.__class__.__name__}".')
    return data


def generate_basket(plugin_file, config=None, old_data=None):
    if config is None:
        config = {}
    if 'variants' not in config:
        config['variants'] = DEFAULT_VARIANTS

    plugin_args = get_plugin_args(plugin_file)
    if plugin_args is None:
        return None

    check_name = os.path.basename(plugin_file).removesuffix('3')

    data = get_data_template()

    if 'linux' in config['variants']:
        print('Generating "linux" variant.')
        command_object_name = f'cmd-check-{check_name}'
        service_object_name = f'tpl-service-{check_name}'
        command = f'/usr/lib64/nagios/plugins/{check_name}'
        varname_suffix = ''

        data = get_command_template(
            data,
            command_object_name,
            command
        )

        data = get_service_template(
            data,
            service_object_name,
            command_object_name,
            check_name,
            plugin_args.description
        )

        data = parse_plugin_args(
            data,
            plugin_args,
            check_name,
            command_object_name,
            service_object_name,
            varname_suffix
        )

    if 'windows' in config['variants']:
        print('Generating "windows" variant.')
        command_object_name += '-windows'
        service_object_name += '-windows'
        command = f'C:\\ProgramData\\icinga2\\usr\\lib64\\nagios\\plugins\\{check_name}\\{check_name}.exe'
        varname_suffix = '_windows'

        data = get_command_template(
            data,
            command_object_name,
            command
        )

        data = get_service_template(
            data,
            service_object_name,
            command_object_name,
            check_name,
            plugin_args.description
        )

        data = parse_plugin_args(
            data,
            plugin_args,
            check_name,
            command_object_name,
            service_object_name,
            varname_suffix
        )

    if 'variants' in config:
        if 'sudo' in config['variants']:
            print('Generating "sudo" variant.')
            data = get_command_template(
                data,
                f'cmd-check-{check_name}-sudo',
                f'/usr/bin/sudo /usr/lib64/nagios/plugins/{check_name}',
                imports=[
                    f'cmd-check-{check_name}',
                ]
            )

        if 'no-agent' in config['variants']:
            print('Generating "no-agent" variant.')
            data = get_service_template(
                data,
                f'tpl-service-{check_name}-no-agent',
                f'cmd-check-{check_name}',
                check_name,
                plugin_args.description
            )

        if 'windows' in config['variants']:
            data = get_command_template(
                data,
                f'cmd-check-{check_name}-windows-python',
                f'C:\\Windows\\py C:\\ProgramData\\icinga2\\usr\\lib64\\nagios\\plugins\\{check_name}.py',
                imports=[
                    f'cmd-check-{check_name}-windows',
                ]
            )

    if 'overwrites' in config:
        print('Applying overwrites.')
        data = apply_overwrites(data, config['overwrites'])

    return manage_uuids(data, old_data)


def main():
    args = parse_args()

    if args.PLUGIN_FILE:
        plugin_dir = os.path.dirname(args.PLUGIN_FILE)
        check = os.path.basename(args.PLUGIN_FILE).removesuffix('3')

        output_file = os.path.join(plugin_dir, 'icingaweb2-module-director', f'{check}.json')
        old_data = None
        if os.path.isfile(output_file):
            with open(output_file, 'rb') as file:
                print(f'Found an existing basket at {output_file}, updating it.')
                old_data = json.load(file)
        else:
            try:
                os.mkdir(os.path.join(plugin_dir, 'icingaweb2-module-director'))
            except FileExistsError:
                pass

        config_file = os.path.join(plugin_dir, 'icingaweb2-module-director', f'{check}.yml')
        config = None
        if os.path.isfile(config_file):
            with open(config_file, 'rb') as file:
                print(f'Using config at {config_file}.')
                config = yaml.safe_load(file)

        save_json_to_file(generate_basket(args.PLUGIN_FILE, config, old_data), output_file)

    elif args.AUTO:
        directories = os.listdir('check-plugins')
        for directory in directories:
            if directory in skip_plugins:
                continue

            plugin_file = os.path.join('check-plugins', directory, directory + '3')
            if os.path.isfile(plugin_file):
                print('\n' + '- ' * 40)
                print(f'Check: {directory}')
                print('- ' * 40)
                old_data = None
                output_file = os.path.join('check-plugins', directory, 'icingaweb2-module-director', f'{directory}.json')
                if os.path.isfile(output_file):
                    with open(output_file, 'rb') as file:
                        print(f'Found an existing basket at {output_file}, updating it.')
                        old_data = json.load(file)
                else:
                    try:
                        os.mkdir(os.path.join('check-plugins', directory, 'icingaweb2-module-director'))
                    except FileExistsError:
                        pass

                plugin_data = generate_basket(plugin_file, old_data)
                if plugin_data:
                    save_json_to_file(plugin_data, output_file)
                else:
                    err_print(f'No data for {directory}.')

    else:
        err_print('Either --auto or --plugin-file is required.')
        sys.exit(2)


if __name__ == '__main__':
    main()
