#!/usr/bin/env python3
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

import argparse
import json
import re
import sys


__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020123101'

DESCRIPTION = 'todo'


def parse_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V',
        '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__),
    )

    parser.add_argument(
        'INPUT_FILE',
        help='Set the input file.',
    )

    return parser.parse_args()

def get_panels(panels):
    panel_list = []
    for panel in panels:
        if panel['type'] == 'row':
            panel_list += get_panels(panel['panels'])
        else:
            # assume everything else is a panel
            # panel_list.append((panel['id'], panel['title'] + panel['description']))
            panel_list.append(panel)
    return panel_list

def generate_new_dashboards(data, new_panels, new_title, new_uid):
    data['panels'][:] = new_panels

    # re-number the panel ids
    for index, panel in enumerate(data['panels']):
        panel['id'] = index + 1

    data['title'] = new_title
    data['uid'] = new_uid
    return data

def save_json_to_file(data, filename):
    try:
        with open(filename, 'w') as file:
            json.dump(data, file, sort_keys=True, indent=4, separators=(',', ': '))
    except FileNotFoundError as e:
        print(f'{e}. Ignoring...')

def get_user_selection(prompt, options):
    print(prompt)
    print('- ' * 40)
    for index, item in enumerate(options):
        print(f'{index}: {item}')
    print('- ' * 40)
    try:
        selection = input("Select the appropriate numbers separated by commas, 'r' to switch to regex mode or 'q' to return: ").strip().strip(',')
        if not selection or selection.lower() == 'q':
            return None
        if selection.lower() == 'r':
            regex = re.compile(str(input("Regex: ")))
            return [index for index, option in enumerate(options) if bool(regex.match(str(option)))]
        return [int(item.strip()) for item in selection.split(',')]
    except KeyboardInterrupt:
        sys.exit()
    except ValueError:
        print('Failed to parse selection.')
        sys.exit(3)

def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit:
        sys.exit(3)

    with open(args.INPUT_FILE, 'rb') as file:
        data = json.load(file)

    type_indices = get_user_selection('What should we place into the new Basket?', data.keys())
    if type_indices is None:
        print('No selection, exiting...')
        sys.exit()
    data_keys_list = list(data.keys())

    new_basket = {}
    for type_index in type_indices:
        cur_type = data_keys_list[type_index]
        data_cur_type_keys_list = list(data[cur_type].keys())
        print('\n')
        selection = get_user_selection(f'Select {cur_type}s', data_cur_type_keys_list)
        if selection is None:
            continue
        object_names = [data_cur_type_keys_list[index] for index in selection]
        new_basket[cur_type] = {}
        for object_name in object_names:
            new_basket[cur_type][object_name] = data[cur_type][object_name]

    # add needed datafields, according to library/Director/DirectorObject/Automation/BasketSnapshotFieldResolver.php:148 from the icingaweb2-module-director
    required_datafield_ids = []
    for objects in new_basket.values():
        for cur_object in objects.values():
            if cur_object.get('fields'):
                fields = cur_object.get('fields')
                required_datafield_ids += [str(field['datafield_id']) for field in fields]

    if required_datafield_ids and 'Datafield' not in new_basket:
        new_basket['Datafield'] = {}

    for datafield_id in required_datafield_ids:
        new_basket['Datafield'][datafield_id] = data['Datafield'][datafield_id]

    out_filename = input('Choose the filename: ').strip()
    save_json_to_file(new_basket, out_filename)

if __name__ == '__main__':
    main()
