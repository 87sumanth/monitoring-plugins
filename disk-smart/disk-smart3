#! /usr/bin/env python3
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://nagios-plugins.org/doc/guidelines.html

__author__  = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2019120401'

DESCRIPTION = 'This check is more or less a user interface for smartctl, which is a tool for querying and controlling SMART (Self-Monitoring, Analysis, and Reporting Technology) data in hard disk and solid-state drives. It allows you to inspect the drive\'s SMART data to determine its health.'

command_installed = '/usr/bin/command -v smartctl'
command_list_disks = 'lsblk --nodeps --noheadings --output name,type --scsi'
command_smartctl  = 'smartctl --xall {disk_path}'
# command_smartctl = 'cat examples/EXAMPLE08'


DEFAULT_IGNORE = []


#====================
import argparse
import datetime
import tempfile
import re

from lib3.globals import *
from lib3.utils import execute_command
from lib3.output import unpack_perfdata, state_to_string
from lib3.parse_arguments import csv_arg


def define_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument('-V', '--version', action='version', version=f'%(prog)s: v{__version__} by {__author__}')
    parser.add_argument('-i', '--ignore', help='A comma-separated list of disks which should be ignored, in the format \'sda,sdb\'. Default: %(default)s', default=DEFAULT_IGNORE, type=csv_arg, dest='IGNORE')

    return parser.parse_args()


def main():
    # parse the command line
    parsed = define_args()

    IGNORE = parsed.IGNORE

    # execute the shell command and return its result and exit code
    stdout, stderr, retc = execute_command(command_installed)
    if (retc != 0):
        print('smartctl missing. Use yum install smartmontools')
        exit(STATE_UNKNOWN)


    # execute the shell command and return its result and exit code
    stdout, stderr, retc = execute_command(command_list_disks)
    if (stderr or retc != 0):
        print(f'Bash command `{command_list_disks}` failed.')
        print(f'Stdout: {stdout}\nStderr: {stderr}')
        exit(STATE_UNKNOWN)

    # compile regex for faster performance
    regex_error_count = re.compile(rb'^(?:ATA|Device) Error Count:[ \t]*([0-9]+)', re.M | re.I)

    # flags to keep track of the current section we are in
    in_section_information = True
    in_section_information_warning = False
    current_warning = ''
    in_section_data = False
    in_subsection_attributes = False
    in_subsection_devstat = False
    in_subsection_error_log = False
    in_subsection_error_log_error = False

    smartctl_data = []
    perfdata = ''
    for line in stdout.splitlines():
        disk, disk_type = line.split()
        disk = disk.decode()
        if disk not in IGNORE and b'disk' in disk_type:
            formatted_command_smartctl = command_smartctl.format(disk_path=f'/dev/{disk}')
            stdout, stderr, retc = execute_command(formatted_command_smartctl)
            if (stderr):
                print(f'Bash command `{formatted_command_smartctl} failed.')
                print(f'Stdout: {stdout}\nStderr: {stderr}')
                exit(STATE_UNKNOWN)

            # compare the retc using bitmasks according to the man page
            if (retc & 1):
                print(f'Smartctl failed with the exit status "Command line did not parse."')
                exit(STATE_UNKNOWN)

            if (retc & 2):
                print(f'Smartctl failed with the exit status "Device open failed, device did not return an IDENTIFY DEVICE structure, or device is in  a  low-power mode."')
                exit(STATE_WARN)


            temp = {}
            temp['disk'] = disk
            continue_flag = False
            in_section_information = True # this is always the first section of each disk
            for line in stdout.splitlines():
                # section information
                if in_section_information:
                    # === START OF INFORMATION SECTION ===
                    # Model Family:     Western Digital RE4
                    # Device Model:     WDC WD1003FBYZ-010FB0
                    # Serial Number:    WD-WCAW3PNKXJ1F
                    # LU WWN Device Id: 5 0014ee 20a80578e
                    # Firmware Version: 01.01V03
                    # User Capacity:    1’000’204’886’016 bytes [1.00 TB]
                    # Sector Size:      512 bytes logical/physical
                    # Rotation Rate:    7200 rpm
                    # Device is:        In smartctl database [for details use: -P show]
                    # ATA Version is:   ATA8-ACS (minor revision not indicated)
                    # SATA Version is:  SATA 3.0, 6.0 Gb/s (current: 6.0 Gb/s)
                    # Local Time is:    Tue Dec  3 16:05:32 2019 CET
                    # SMART support is: Available - device has SMART capability.
                    # SMART support is: Enabled
                    # AAM feature is:   Unavailable
                    # APM level is:     128 (minimum power consumption without standby)
                    # Rd look-ahead is: Enabled
                    # Write cache is:   Enabled
                    # DSN feature is:   Unavailable
                    # ATA Security is:  Disabled, NOT FROZEN [SEC1]
                    # Wt Cache Reorder: Enabled

                    # find the end of the section information (start of section data)
                    if line.startswith(b'=== START OF READ SMART DATA SECTION ==='):
                        in_section_information = False
                        in_section_data = True
                        continue

                    if line.startswith(b'Model Family:'):
                        temp['model_family'] = line.split(b':')[1].decode().strip()

                    if line.startswith(b'Device Model:'):
                        temp['device_model'] = line.split(b':')[1].decode().strip()

                    if line.startswith(b'Serial Number:'):
                        temp['serial_number'] = line.split(b':')[1].decode().strip()

                    if line.startswith(b'SMART support is'):
                        if b'Disabled' in line:
                            temp['state'] = get_greater_state(STATE_UNKNOWN, temp.get('state', STATE_OK))
                            temp['msg'] = temp.get('msg', '') + '* General: SMART on drive is disabled. You should enable it to read any SMART information from this drive. Additionally, some drives do not log useful data with SMART disabled, so it\'s advisable to keep it always enabled.\n'
                            continue_flag = True
                            break
                        
                        if b'Unavailable' in line:
                            temp['state'] = get_greater_state(STATE_UNKNOWN, temp.get('state', STATE_OK))
                            temp['msg'] = temp.get('msg', '') + '* General: SMART on drive is not supported. You won\'t be able to read any SMART information from this drive. Consider adding it to the ignore list.\n'
                            continue_flag = True
                            break

                    if in_section_information_warning:
                        # find the end of the current warning
                        if line == b'':
                            in_section_information_warning = False
                            # evaluate, then clear the current warning
                            if 'mandatory SMART command failed' not in current_warning\
                            and 'Enabled status cached by OS, trying SMART RETURN STATUS cmd' not in current_warning\
                            and not current_warning.startswith('Unexpected SCT status')\
                            and not current_warning.startswith('Write SCT (Get) XXX Error Recovery Control Command failed')\
                            and not current_warning.startswith('Write SCT (Get) Feature Control Command failed')\
                            and not current_warning.startswith('Read SCT Status failed')\
                            and not current_warning.startswith('Read SMART Data failed')\
                            and not current_warning.startswith('Unknown SCT Status format version')\
                            and not current_warning.startswith('Read SMART Thresholds failed')\
                            and not current_warning.startswith('>> Terminate command early due to bad response to IEC mode page')\
                            and not current_warning.startswith('scsiModePageOffset:'):
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* General: Drive may be affected by a warning, please see the details: "{current_warning.strip()}"\n'

                            current_warning = ''
                        else:
                            current_warning += line.decode() + '\n'

                    # find the start of the current warning
                    if line.startswith(b'==> WARNING: '):
                        in_section_information_warning = True
                        current_warning += line.decode().replace('==> WARNING: ', '') + '\n'


                # section data
                if in_section_data:
                    # subsection_health
                    # === START OF READ SMART DATA SECTION ===
                    # SMART overall-health self-assessment test result: PASSED
                    if line.startswith(b'SMART overall-health self-assessment'):
                        if b'PASSED' not in line.split(b':')[1].strip():
                            temp['state'] = get_greater_state(STATE_CRIT, temp.get('state', STATE_OK))
                            temp['msg'] = temp.get('msg', '') + '* Overall Health Self-Assessment Test: FAILED! Drive is reporting that it will FAIL very soon. Please back up as soon as possible!\n'

                    # subsection_attributes
                    # SMART Attributes Data Structure revision number: 16
                    # Vendor Specific SMART Attributes with Thresholds:
                    # ID# ATTRIBUTE_NAME          FLAGS    VALUE WORST THRESH FAIL RAW_VALUE
                    #   1 Raw_Read_Error_Rate     POSR-K   200   200   051    -    2
                    if in_subsection_attributes:
                        # find the end of the attribute subsection
                        if line.startswith(b'         '):
                            in_subsection_attributes = False
                            continue

                        perfdata_prefix = f'{temp.get("disk", "")}_{temp.get("device_model", "").replace(" ", "_")}_{temp.get("serial_number", "")}'
                        split_line = line.decode().split()

                        # First go through all attributes and check the FAIL column. If it's 'NOW' set the state and go to the next line, else we look at the values
                        fail = split_line[6]
                        if 'NOW' in fail:
                            # check if pre-fail or old_age
                            flags = split_line[2]
                            if 'P' in flags:
                                # pre-fail
                                temp['state'] = get_greater_state(STATE_CRIT, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: Drive has a failing pre-fail attribute ("{split_line[0]} {split_line[1]}"). Usually this indicates that the drive will FAIL soon. Please back up immediately!\n'
                                continue
                            else:
                                # old_age
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: Drive has a failing old-age attribute ("{split_line[0]} {split_line[1]}"). Usually this indicates a wear-out. You should consider replacing the drive.\n'
                                continue
                        elif 'Past' in fail:
                            # check if pre-fail or old_age
                            if 'P' in flags:
                                # pre-fail
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: had a failing pre-fail attribute ("{split_line[0]} {split_line[1]}"), but it has been restored to a normal value. This may be a serious problem, you should consider replacing the drive.\n'
                                continue
                            else:
                                # old_age - do nothing. We don't warn about e.g. temperature increase in the past
                                continue

                        if line.startswith(b'  5 Reallocated_Sector_Ct'):
                            raw_value = int(split_line[7])
                            if raw_value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: Drive has a non-zero Raw value ("{split_line[0]} {split_line[1]}"), but there is no SMART warning yet. This could be an indication of future failures and/or potential data loss in bad sectors.\n'

                        if line.startswith(b' 10 Spin_Retry_Count'):
                            raw_value = int(split_line[7])
                            if raw_value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: Drive has a non-zero Raw value ("{split_line[0]} {split_line[1]}"), but there is no SMART warning yet. Your drive may have problems spinning up, which could lead to a complete mechanical failure. Please back up.\n'

                        if line.startswith(b' 13 Read_Soft_Error_Rate'):
                            raw_value = int(split_line[7])
                            if raw_value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: Drive has a non-zero Raw value ("{split_line[0]} {split_line[1]}"), but there is no SMART warning yet. This could be an indication of future failures and/or potential data loss in bad sectors.\n'

                        if line.startswith(b'190 Temperature_Celsius')\
                        or line.startswith(b'194 Temperature_Celsius')\
                        or line.startswith(b'194 Airflow_Temperature')\
                        or line.startswith(b'194 Temperature_Celsius')\
                        or line.startswith(b'194 Temperature_Internal')\
                        or line.startswith(b'231 Temperature_Celsius'):
                            raw_value = int(split_line[7])
                            perfdata += unpack_perfdata(f'{perfdata_prefix}_{split_line[0]}_{split_line[1]}', raw_value, None, None, None, 0, None)
                            if raw_value > 50:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: The temperature of drive is higher than 50 degrees Celsius. This may shorten its lifespan and cause damage under severe load. Please install a cooling solution.\n'

                        if line.startswith(b'194 Temperature_Celsius_x10'):
                            raw_value = int(split_line[7])
                            perfdata += unpack_perfdata(f'{perfdata_prefix}_{split_line[0]}_{split_line[1]}', raw_value, None, None, None, 0, None)
                            if raw_value > 500:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + '* Attributes: The temperature of drive is higher than 50 degrees Celsius. This may shorten its lifespan and cause damage under severe load. Please install a cooling solution.\n'

                        if line.startswith(b'196 Reallocated_Event_Count'):
                            raw_value = int(split_line[7])
                            if raw_value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: Drive has a non-zero Raw value ("{split_line[0]} {split_line[1]}"), but there is no SMART warning yet. This could be an indication of future failures and/or potential data loss in bad sectors.\n'

                        if line.startswith(b'197 Current_Pending_Sector')\
                        or line.startswith(b'197 Total_Pending_Sectors'):
                            raw_value = int(split_line[7])
                            if raw_value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: Drive has a non-zero Raw value ("{split_line[0]} {split_line[1]}"), but there is no SMART warning yet. This could be an indication of future failures and/or potential data loss in bad sectors.\n'

                        if line.startswith(b'198 Offline_Uncorrectable')\
                        or line.startswith(b'198 Total_Offl_Uncorrectabl'):
                            raw_value = int(split_line[7])
                            if raw_value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: Drive has a non-zero Raw value ("{split_line[0]} {split_line[1]}"), but there is no SMART warning yet. This could be an indication of future failures and/or potential data loss in bad sectors.\n'

                        if line.startswith(b'  5 Retired_Block_Count')\
                        or line.startswith(b'169 Remaining_Lifetime_Perc')\
                        or line.startswith(b'202 Percent_Lifetime_Remain')\
                        or line.startswith(b'209 Remaining_Lifetime_Perc')\
                        or line.startswith(b'231 SSD_Life_Left')\
                        or line.startswith(b'232 Perc_Avail_Resrvd_Space')\
                        or line.startswith(b'232 Spares_Remaining_Perc')\
                        or line.startswith(b'233 Media_Wearout_Indicator')\
                        or line.startswith(b'233 Remaining_Lifetime_Perc'):
                            value = int(split_line[3])
                            perfdata += unpack_perfdata(f'{perfdata_prefix}_{split_line[0]}_{split_line[1]}', raw_value, None, None, None, 0, 100)
                            if value < 50:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: Drive has less than half of its estimated life left ("{split_line[0]} {split_line[1]}").\n'

                        if line.startswith(b'202 Percent_Lifetime_Used'):
                            raw_value = int(split_line[7])
                            perfdata += unpack_perfdata(f'{perfdata_prefix}_{split_line[0]}_{split_line[1]}', raw_value, None, None, None, 0, 100)
                            if raw_value >= 50:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Attributes: Drive has less than half of its estimated life left ("{split_line[0]} {split_line[1]}").\n'

                        # collect perfdata for attributes that are not evaluated
                        if line.startswith(b'  9 Power_On_Hours')\
                        or line.startswith(b' 12 Power_Cycle_Count'):
                            raw_value = int(split_line[7])
                            perfdata += unpack_perfdata(f'{perfdata_prefix}_{split_line[0]}_{split_line[1]}', raw_value, None, None, None, 0, None)

                    # find the start of the attribute subsection
                    if line.startswith(b'Vendor Specific SMART Attributes with Thresholds'):
                        in_subsection_attributes = True

                    # subsection_devstat
                    # Device Statistics (GP Log 0x04)
                    # Page  Offset Size        Value Flags Description
                    # 0x01  =====  =               =  ===  == General Statistics (rev 1) ==
                    # 0x01  0x008  4             569  -D-  Lifetime Power-On Resets
                    # 0x01  0x010  4            6360  -D-  Power-on Hours
                    # 0x01  0x018  6     17887792526  -D-  Logical Sectors Written
                    # 0x01  0x020  6        51609191  -D-  Number of Write Commands
                    # 0x01  0x028  6     17634698564  -D-  Logical Sectors Read
                    # 0x01  0x030  6       179799274  -D-  Number of Read Commands
                    # 0x01  0x038  6      1421163520  -D-  Date and Time TimeStamp
                    # 0x01  0x048  2             202  ND-  Workload Utilization
                    # 0x03  =====  =               =  ===  == Rotating Media Statistics (rev 1) ==
                    # 0x03  0x008  4            6356  -D-  Spindle Motor Power-on Hours
                    # 0x03  0x010  4            6356  -D-  Head Flying Hours
                    #                                 |||_ C monitored condition met
                    #                                 ||__ D supports DSN
                    #                                 |___ N normalized value

                    if in_subsection_devstat:
                        # find the end of the devstat subsection
                        if line.startswith(b'         '):
                            in_subsection_devstat = False
                            # skip to next disk because the error log is the last section that needs to be evaluated
                            continue_flag = True
                            break

                        split_line = line.decode().split()
                        description = ' '.join(split_line[5:])

                        if 'Pending Error Count' in description:
                            value = int(split_line[3])
                            if value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Statistics: Drive is reporting surface errors ("{description}"). This could be an indication of future failures and/or potential data loss in bad sectors.\n'

                        if 'Utilization Usage Rate' in description\
                        or 'Percentage Used Endurance Indicator' in description:
                            value = int(split_line[3])
                            if value >= 50:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Statistics: Drive is reporting surface errors ("{description}"). This could be an indication of future failures and/or potential data loss in bad sectors.\n'
                            if value >= 100:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Statistics: Drive is past its estimated lifespan.\n'

                        if 'Number of Reallocated Logical Sectors' in description:
                            # check if value is normalized or not
                            flags = split_line[4]
                            value = int(split_line[3])
                            if 'N' in flags:
                                # normalized
                                if value <= 0:
                                    temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                    temp['msg'] = temp.get('msg', '') + f'* Statistics: Drive is reporting surface errors ("{description}"). This could be an indication of future failures and/or potential data loss in bad sectors.\n'
                            else:
                                # not normalized
                                if value > 0:
                                    temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                    temp['msg'] = temp.get('msg', '') + f'* Statistics: Drive is reporting surface errors ("{description}"). This could be an indication of future failures and/or potential data loss in bad sectors.\n'

                        if 'Number of Mechanical Start Failures' in description:
                            value = int(split_line[3])
                            if value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Statistics: Drive is reporting mechanical errors ("{description}").\n'

                        if 'Number of Realloc. Candidate Logical Sectors' in description\
                        or 'Number of Reported Uncorrectable Errors' in description:
                            value = int(split_line[3])
                            if value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Statistics: Drive is reporting surface errors ("{description}"). This could be an indication of future failures and/or potential data loss in bad sectors.\n'

                        if 'Current Temperature' in description:
                            value = int(split_line[3])
                            if value > 50:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Statistics: The temperature of the drive is higher than 50 degrees Celsius. This may shorten its lifespan and cause damage under severe load. Please install a cooling solution.\n'

                        if 'Time in Over-Temperature' in description:
                            value = int(split_line[3])
                            if value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Statistics: The temperature of the drive is or was over the manufacturer-specified maximum. This may have shortened its lifespan and caused damage. Please install a cooling solution.\n'

                        if 'Time in Under-Temperature' in description:
                            value = int(split_line[3])
                            if value > 0:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Statistics: The temperature of the drive is or was under the manufacturer-specified maximum. This may have shortened its lifespan and caused damage. Please operate the drive within manufacturer-specified temperature range.\n'

                    # find the start of the devstat subsection
                    # Device Statistics (GP Log 0x04)
                    # but not:
                    # Device Statistics (GP/SMART Log 0x04) not supported
                    if line.startswith(b'Device Statistics') and b'not supported' not in line:
                        in_subsection_devstat = True


                    # subsection_error_log
                    # SMART Extended Comprehensive Error Log Version: 1 (1 sectors)
                    # Device Error Count: 1
                    #     CR     = Command Register
                    #     FEATR  = Features Register
                    #     COUNT  = Count (was: Sector Count) Register
                    #     LBA_48 = Upper bytes of LBA High/Mid/Low Registers ]  ATA-8
                    #     LH     = LBA High (was: Cylinder High) Register    ]   LBA
                    #     LM     = LBA Mid (was: Cylinder Low) Register      ] Register
                    #     LL     = LBA Low (was: Sector Number) Register     ]
                    #     DV     = Device (was: Device/Head) Register
                    #     DC     = Device Control Register
                    #     ER     = Error register
                    #     ST     = Status register
                    # Powered_Up_Time is measured from power on, and printed as
                    # DDd+hh:mm:SS.sss where DD=days, hh=hours, mm=minutes,
                    # SS=sec, and sss=millisec. It "wraps" after 49.710 days.

                    # Error 1 [0] occurred at disk power-on lifetime: 1 hours (0 days + 1 hours)
                    #   When the command that caused the error occurred, the device was active or idle.

                    #   After command completion occurred, registers were:
                    #   ER -- ST COUNT  LBA_48  LH LM LL DV DC
                    #   -- -- -- == -- == == == -- -- -- -- --
                    #   02 -- 51 00 00 00 00 00 00 00 00 00 00  Error: TK0NF

                    #   Commands leading to the command that caused the error were:
                    #   CR FEATR COUNT  LBA_48  LH LM LL DV DC  Powered_Up_Time  Command/Feature_Name
                    #   -- == -- == -- == == == -- -- -- -- --  ---------------  --------------------
                    #   10 00 00 00 01 00 00 00 00 03 34 e0 ff     00:00:17.305  RECALIBRATE [OBS-4]
                    #   10 00 00 00 01 00 00 00 00 03 34 e0 08     00:00:17.138  RECALIBRATE [OBS-4]
                    #   91 40 00 01 3f 00 00 01 00 03 34 af 08     00:00:17.138  INITIALIZE DEVICE PARAMETERS [OBS-6]
                    #   c4 00 40 00 00 00 00 3f 00 00 00 e0 04     00:00:16.934  READ MULTIPLE
                    #   c4 00 40 00 01 00 00 3f 00 00 00 e0 00     00:00:07.959  READ MULTIPLE

                    if in_subsection_error_log:
                        # continue if no errors are found or find the end of the devstat subsection
                        if line.startswith(b'No Errors Logged')\
                        or line.startswith(b'SMART Extended Self-test Log'):
                            in_subsection_error_log = False
                            # the errors span from the first 'Error' to to end of the error_log subsection
                            in_subsection_error_log_error = False
                            continue



                        matches = re.search(regex_error_count, line)
                        if matches:
                            temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                            temp['msg'] = temp.get('msg', '') + f'* Error Log: Drive is reporting {int(matches[1])} internal errors. Usually this means uncorrectable data loss and similar severe errors. Check the actual errors for details.\n'

                        if in_subsection_error_log_error:
                            if b'AMNF' in line:
                                temp['state'] = get_greater_state(STATE_CRIT, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Error Log: Drive is reporting internal errors ("Address mark not found"). Usually this means uncorrectable data loss and similar severe errors. Check the actual errors for details.\n'

                            if b'CCTO' in line:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Error Log: Drive is reporting internal errors ("Command completion timed out"). Usually this means uncorrectable data loss and similar severe errors. Check the actual errors for details.\n'

                            if b'EOM' in line:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Error Log: Drive is reporting internal errors ("End of media"). Usually this means uncorrectable data loss and similar severe errors. Check the actual errors for details.\n'

                            if b'ICRC' in line:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Error Log: Drive is reporting internal errors ("Interface CRC error"). Usually this means uncorrectable data loss and similar severe errors. Check the actual errors for details.\n'

                            if b'IDNF' in line:
                                temp['state'] = get_greater_state(STATE_CRIT, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Error Log: Drive is reporting internal errors ("Identity not found"). Usually this means uncorrectable data loss and similar severe errors. Check the actual errors for details.\n'


                            if b'ILI' in line:
                                temp['state'] = get_greater_state(STATE_WARN, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Error Log: Drive is reporting internal errors ("Packet command-set specific"). Usually this means uncorrectable data loss and similar severe errors. Check the actual errors for details.\n'


                            if b'TK0NF' in line:
                                temp['state'] = get_greater_state(STATE_CRIT, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Error Log: Drive is reporting internal errors ("Track 0 not found"). Usually this means uncorrectable data loss and similar severe errors. Check the actual errors for details.\n'


                            if b'UNC' in line:
                                temp['state'] = get_greater_state(STATE_CRIT, temp.get('state', STATE_OK))
                                temp['msg'] = temp.get('msg', '') + f'* Error Log: Drive is reporting internal errors ("Uncorrectable error in data"). Usually this means uncorrectable data loss and similar severe errors. Check the actual errors for details.\n'


                        # find the start of an error block
                        if line.startswith(b'Error '):
                            in_subsection_error_log_error = True


                    # find the start of the error_log subsection
                    if line.startswith(b'SMART Extended Comprehensive Error Log'):
                        in_subsection_error_log = True

            smartctl_data.append(temp)
            if continue_flag:
                # skip to next disk
                continue


    # calculating the final check state and generate the output message
    msg = ''
    overall_state = STATE_OK
    disk_counter = 0
    for disk in smartctl_data:
        disk_counter += 1
        msg += f'\n{state_to_string(disk.get("state", STATE_OK))} "{disk["disk"]} ({disk["device_model"]}, SerNo: {disk["serial_number"]})"\n'
        msg += disk.get('msg', '')
        overall_state = get_greater_state(disk.get("state", STATE_OK), overall_state)

    if overall_state == STATE_CRIT:
        print(f'Checked {disk_counter} disk(s). There are critical errors.')
    elif overall_state == STATE_WARN:
        print(f'Checked {disk_counter} disk(s). There are warnings.')
    else:
        print(f'Checked {disk_counter} disk(s). All are healthy.')

    print(msg)

    # print out perfdata
    print(f'|{perfdata}')

    exit(overall_state)


if __name__ == '__main__':
    main()
