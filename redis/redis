#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://nagios-plugins.org/doc/guidelines.html

# https://redis.io/topics/memory-optimization


__author__  = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020020401'

DESCRIPTION = 'Checks redis health.'

command_redis = 'INFO' # redis-cli

# Memory
DEFAULT_W_MAXMEMORY = None
DEFAULT_C_MAXMEMORY = None

DEFAULT_W_MEM_FRAGMENTATION_RATIO = None
DEFAULT_C_MEM_FRAGMENTATION_RATIO = None

DEFAULT_W_USED_MEMORY = None
DEFAULT_C_USED_MEMORY = None

DEFAULT_W_USED_MEMORY_PERCENTAGE = 80
DEFAULT_C_USED_MEMORY_PERCENTAGE = 90

DEFAULT_W_USED_MEMORY_PEAK = None
DEFAULT_C_USED_MEMORY_PEAK = None

DEFAULT_W_USED_MEMORY_PEAK_PERCENTAGE = 80
DEFAULT_C_USED_MEMORY_PEAK_PERCENTAGE = 90

DEFAULT_W_USED_MEMORY_RSS = None
DEFAULT_C_USED_MEMORY_RSS = None

# Persistence
DEFAULT_W_RDB_CHANGES_SINCE_LAST_SAVE = None
DEFAULT_C_RDB_CHANGES_SINCE_LAST_SAVE = None

DEFAULT_W_RDB_LAST_SAVE_TIME = None
DEFAULT_C_RDB_LAST_SAVE_TIME = None

# Clients
DEFAULT_W_BLOCKED_CLIENTS = None
DEFAULT_C_BLOCKED_CLIENTS = None

DEFAULT_W_CONNECTED_CLIENTS = None
DEFAULT_C_CONNECTED_CLIENTS = None

# Stats
DEFAULT_W_EVICTED_KEYS = None
DEFAULT_C_EVICTED_KEYS = None

DEFAULT_W_REJECTED_CONNECTIONS = None
DEFAULT_C_REJECTED_CONNECTIONS = None

# Replication
DEFAULT_W_CONNECTED_SLAVES = None
DEFAULT_C_CONNECTED_SLAVES = None


DEFAULT_HOSTNAME = '127.0.0.1'
DEFAULT_PORT = 6379
DEFAULT_PASSWORD = None
DEFAULT_SOCKET_TIMEOUT = 10

# Linux Server Configuration
SOMAXCONN_WARN = 512
SOMAXCONN_CRIT = None

OVERCOMMIT_MEMORY_EXPECTED_VALUE = 1

TRANSPARENT_HUGEPAGE_EXPECTED_VALUE = 'always madvise [never]'


#====================
import argparse
import socket
import datetime

from lib.globals import *
from lib.output import unpack_perfdata, unix_time_to_iso, state_to_string
from lib.parse_arguments import csv
from lib.parse_input import evaluate_greater, evaluate_greater_datetime_to_now, evaluate_smaller


def define_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument('-V', '--version',
        action = 'version',
        version = '{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
        )

    parser.add_argument('-H', '--hostname',
        help = 'Set the hostname of the redis Server. Default: %(default)s',
        dest = 'HOSTNAME',
        type = str,
        default = DEFAULT_HOSTNAME,
        )

    parser.add_argument('-P', '--port',
        help = 'Set the port of the redis Server. Default: %(default)s',
        dest = 'PORT',
        type = int,
        default = DEFAULT_PORT,
        )

    parser.add_argument('-p', '--password',
        help = 'Set the password for the redis Server. Default: %(default)s',
        dest = 'PASSWORD',
        type = str,
        default = DEFAULT_PASSWORD,
        )

    parser.add_argument('-t', '--timeout',
        help = 'Set the timeout to the redis socket. Default: %(default)s',
        dest = 'SOCKET_TIMEOUT',
        type = int,
        default = DEFAULT_SOCKET_TIMEOUT,
        )

    parser.add_argument('--w_maxmemory',
        help = 'Set the warning threshold for maxmemory. Default: %(default)s',
        dest = 'W_MAXMEMORY',
        type = int,
        default = DEFAULT_W_MAXMEMORY,
        )
    parser.add_argument('--c_maxmemory',
        help = 'Set the critical threshold for maxmemory. Default: %(default)s',
        dest = 'C_MAXMEMORY',
        type = int,
        default = DEFAULT_C_MAXMEMORY,
        )
    
    parser.add_argument('--w_mem_fragmentation_ratio',
        help = 'Set the warning threshold for mem_fragmentation_ratio. Default: %(default)s',
        dest = 'W_MEM_FRAGMENTATION_RATIO',
        type = float,
        default = DEFAULT_W_MEM_FRAGMENTATION_RATIO,
        )
    parser.add_argument('--c_mem_fragmentation_ratio',
        help = 'Set the critical threshold for mem_fragmentation_ratio. Default: %(default)s',
        dest = 'C_MEM_FRAGMENTATION_RATIO',
        type = float,
        default = DEFAULT_C_MEM_FRAGMENTATION_RATIO,
        )

    parser.add_argument('--w_used_memory',
        help = 'Set the warning threshold for used_memory. Default: %(default)s',
        dest = 'W_USED_MEMORY',
        type = int,
        default = DEFAULT_W_USED_MEMORY,
        )
    parser.add_argument('--c_used_memory',
        help = 'Set the critical threshold for used_memory. Default: %(default)s',
        dest = 'C_USED_MEMORY',
        type = int,
        default = DEFAULT_C_USED_MEMORY,
        )

    parser.add_argument('--w_used_memory_percentage',
        help = 'Set the warning threshold for used_memory_percentage. Default: %(default)s%%',
        dest = 'W_USED_MEMORY_PERCENTAGE',
        type = float,
        default = DEFAULT_W_USED_MEMORY_PERCENTAGE,
        )
    parser.add_argument('--c_used_memory_percentage',
        help = 'Set the critical threshold for used_memory_percentage. Default: %(default)s%%',
        dest = 'C_USED_MEMORY_PERCENTAGE',
        type = float,
        default = DEFAULT_C_USED_MEMORY_PERCENTAGE,
        )
    
    parser.add_argument('--w_used_memory_peak',
        help = 'Set the warning threshold for used_memory_peak. Default: %(default)s',
        dest = 'W_USED_MEMORY_PEAK',
        type = int,
        default = DEFAULT_W_USED_MEMORY_PEAK,
        )
    parser.add_argument('--c_used_memory_peak',
        help = 'Set the critical threshold for used_memory_peak. Default: %(default)s',
        dest = 'C_USED_MEMORY_PEAK',
        type = int,
        default = DEFAULT_C_USED_MEMORY_PEAK,
        )

    parser.add_argument('--w_used_memory_peak_percentage',
        help = 'Set the warning threshold for used_memory_peak_percentage. Default: %(default)s%%',
        dest = 'W_USED_MEMORY_PEAK_PERCENTAGE',
        type = float,
        default = DEFAULT_W_USED_MEMORY_PEAK_PERCENTAGE,
        )
    parser.add_argument('--c_used_memory_peak_percentage',
        help = 'Set the critical threshold for used_memory_peak_percentage. Default: %(default)s%%',
        dest = 'C_USED_MEMORY_PEAK_PERCENTAGE',
        type = float,
        default = DEFAULT_C_USED_MEMORY_PEAK_PERCENTAGE,
        )

    parser.add_argument('--w_used_memory_rss',
        help = 'Set the warning threshold for used_memory_rss. Default: %(default)s',
        dest = 'W_USED_MEMORY_RSS',
        type = int,
        default = DEFAULT_W_USED_MEMORY_RSS,
        )
    parser.add_argument('--c_used_memory_rss',
        help = 'Set the critical threshold for used_memory_rss. Default: %(default)s',
        dest = 'C_USED_MEMORY_RSS',
        type = int,
        default = DEFAULT_C_USED_MEMORY_RSS,
        )
    
    parser.add_argument('--w_rdb_changes_since_last_save',
        help = 'Set the warning threshold for rdb_changes_since_last_save. Default: %(default)s',
        dest = 'W_RDB_CHANGES_SINCE_LAST_SAVE',
        type = int,
        default = DEFAULT_W_RDB_CHANGES_SINCE_LAST_SAVE,
        )
    parser.add_argument('--c_rdb_changes_since_last_save',
        help = 'Set the critical threshold for rdb_changes_since_last_save. Default: %(default)s',
        dest = 'C_RDB_CHANGES_SINCE_LAST_SAVE',
        type = int,
        default = DEFAULT_C_RDB_CHANGES_SINCE_LAST_SAVE,
        )

    parser.add_argument('--w_rdb_last_save_time',
        help = 'Set the warning threshold for rdb_last_save_time in hours. Default: %(default)s',
        dest = 'W_RDB_LAST_SAVE_TIME',
        type = int,
        default = DEFAULT_W_RDB_LAST_SAVE_TIME,
        )
    parser.add_argument('--c_rdb_last_save_time',
        help = 'Set the critical threshold for rdb_last_save_time in hours. Default: %(default)s',
        dest = 'C_RDB_LAST_SAVE_TIME',
        type = int,
        default = DEFAULT_C_RDB_LAST_SAVE_TIME,
        )
    
    parser.add_argument('--w_blocked_clients',
        help = 'Set the warning threshold for blocked_clients. Default: %(default)s',
        dest = 'W_BLOCKED_CLIENTS',
        type = int,
        default = DEFAULT_W_BLOCKED_CLIENTS,
        )
    parser.add_argument('--c_blocked_clients',
        help = 'Set the critical threshold for blocked_clients. Default: %(default)s',
        dest = 'C_BLOCKED_CLIENTS',
        type = int,
        default = DEFAULT_C_BLOCKED_CLIENTS,
        )
    
    parser.add_argument('--w_connected_clients',
        help = 'Set the warning threshold for connected_clients. Default: %(default)s',
        dest = 'W_CONNECTED_CLIENTS',
        type = int,
        default = DEFAULT_W_CONNECTED_CLIENTS,
        )
    parser.add_argument('--c_connected_clients',
        help = 'Set the critical threshold for connected_clients. Default: %(default)s',
        dest = 'C_CONNECTED_CLIENTS',
        type = int,
        default = DEFAULT_C_CONNECTED_CLIENTS,
        )
    
    parser.add_argument('--w_evicted_keys',
        help = 'Set the warning threshold for evicted_keys. Default: %(default)s',
        dest = 'W_EVICTED_KEYS',
        type = int,
        default = DEFAULT_W_EVICTED_KEYS,
        )
    parser.add_argument('--c_evicted_keys',
        help = 'Set the critical threshold for evicted_keys. Default: %(default)s',
        dest = 'C_EVICTED_KEYS',
        type = int,
        default = DEFAULT_C_EVICTED_KEYS,
        )
    
    parser.add_argument('--w_rejected_connections',
        help = 'Set the warning threshold for rejected_connections. Default: %(default)s',
        dest = 'W_REJECTED_CONNECTIONS',
        type = int,
        default = DEFAULT_W_REJECTED_CONNECTIONS,
        )
    parser.add_argument('--c_rejected_connections',
        help = 'Set the critical threshold for rejected_connections. Default: %(default)s',
        dest = 'C_REJECTED_CONNECTIONS',
        type = int,
        default = DEFAULT_C_REJECTED_CONNECTIONS,
        )
    
    parser.add_argument('--w_connected_slaves',
        help = 'Set the warning threshold for connected_slaves. Default: %(default)s',
        dest = 'W_CONNECTED_SLAVES',
        type = int,
        default = DEFAULT_W_CONNECTED_SLAVES,
        )
    parser.add_argument('--c_connected_slaves',
        help = 'Set the critical threshold for connected_slaves. Default: %(default)s',
        dest = 'C_CONNECTED_SLAVES',
        type = int,
        default = DEFAULT_C_CONNECTED_SLAVES,
        )

    return parser.parse_args()


def get_info(host, port, timeout, auth):
    socket.setdefaulttimeout(timeout)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect((host, port))
        
        if auth is not None:
            s.send("*2\r\n$4\r\nAUTH\r\n$%d\r\n%s\r\n" % (len(auth),auth))
            result = s.recv(100)
            if not 'OK' in result:
               print('Invalid authentication.')
               exit(STATE_UNKNOWN)

        s.send("*1\r\n$4\r\ninfo\r\n")

        buf_size = 1024
        buf = s.recv(buf_size)

        if not 'redis_version:' in buf:
           print('Failed to read info from redis.')
           exit(STATE_UNKNOWN)

        buf_len = int(buf.split('\r\n')[0][1:])

        buf += s.recv(buf_len)

    except Exception, e:
        print(str(e))
        exit(STATE_UNKNOWN)

    s.close()
    return dict(x.split(':', 1) for x in buf.split('\r\n') if ':' in x)


def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        parsed = define_args()
    except SystemExit as e:
        exit(STATE_UNKNOWN)

    result = get_info(parsed.HOSTNAME, parsed.PORT, parsed.SOCKET_TIMEOUT, parsed.PASSWORD)

    perfdata = ''
    overall_state = STATE_OK
    submsg = '\nServer'

    submsg += '\n' + '* {}: {}'.format('redis_version', result['redis_version'])
    
    submsg += '\n\nMemory'

    maxmemory_state = evaluate_greater(result['maxmemory'], parsed.W_MAXMEMORY, parsed.C_MAXMEMORY)
    overall_state = get_greater_state(overall_state, maxmemory_state)
    perfdata += unpack_perfdata('maxmemory', result['maxmemory'], None, parsed.W_MAXMEMORY, parsed.C_MAXMEMORY, 0, None)
    submsg += '\n* maxmemory: {} {}'.format(result['maxmemory_human'], state_to_string(maxmemory_state))

    mem_fragmentation_ratio_state = evaluate_greater(result['mem_fragmentation_ratio'], parsed.W_MEM_FRAGMENTATION_RATIO, parsed.C_MEM_FRAGMENTATION_RATIO)
    overall_state = get_greater_state(overall_state, mem_fragmentation_ratio_state)
    perfdata += unpack_perfdata('mem_fragmentation_ratio', result['mem_fragmentation_ratio'], None, parsed.W_MEM_FRAGMENTATION_RATIO, parsed.C_MEM_FRAGMENTATION_RATIO, 0, None)
    submsg += '\n* mem_fragmentation_ratio: {} {}'.format(result['mem_fragmentation_ratio'], state_to_string(mem_fragmentation_ratio_state))

    used_memory_state = evaluate_greater(result['used_memory'], parsed.W_USED_MEMORY, parsed.C_USED_MEMORY)
    overall_state = get_greater_state(overall_state, used_memory_state)
    perfdata += unpack_perfdata('used_memory', result['used_memory'], None, parsed.W_USED_MEMORY, parsed.C_USED_MEMORY, 0, None)
    submsg += '\n* used_memory: {} {}'.format(result['used_memory_human'], state_to_string(mem_fragmentation_ratio_state))

    if int(result['maxmemory']) == 0:
        used_memory_percentage_value = round(float(result['used_memory']) / float(result['total_system_memory']) * 100, 2)
    else:
        used_memory_percentage_value = round(float(result['used_memory']) / float(result['maxmemory']) * 100, 2)
    used_memory_percentage_state = evaluate_greater(used_memory_percentage_value, parsed.W_USED_MEMORY_PERCENTAGE, parsed.C_USED_MEMORY_PERCENTAGE)
    perfdata += unpack_perfdata('used_memory_percentage', used_memory_percentage_value, '%', parsed.W_USED_MEMORY_PERCENTAGE, parsed.C_USED_MEMORY_PERCENTAGE, 0, 100)
    submsg += '\n* used_memory_percentage: {} {}'.format(used_memory_percentage_value, state_to_string(used_memory_percentage_state))

    used_memory_peak_state = evaluate_greater(result['used_memory_peak'], parsed.W_USED_MEMORY_PEAK, parsed.C_USED_MEMORY_PEAK)
    overall_state = get_greater_state(overall_state, used_memory_peak_state)
    perfdata += unpack_perfdata('used_memory_peak', result['used_memory_peak'], None, parsed.W_USED_MEMORY_PEAK, parsed.C_USED_MEMORY_PEAK, 0, None)
    submsg += '\n* used_memory_peak: {} {}'.format(result['used_memory_peak_human'], state_to_string(mem_fragmentation_ratio_state))

    if int(result['maxmemory']) == 0:
        used_memory_peak_percentage_value = round(float(result['used_memory_peak']) / float(result['total_system_memory']) * 100, 2)
    else:
        used_memory_peak_percentage_value = round(float(result['used_memory_peak']) / float(result['maxmemory']) * 100, 2)

    used_memory_peak_percentage_state = evaluate_greater(used_memory_peak_percentage_value, parsed.W_USED_MEMORY_PEAK_PERCENTAGE, parsed.C_USED_MEMORY_PEAK_PERCENTAGE)
    perfdata += unpack_perfdata('used_memory_peak_percentage', used_memory_peak_percentage_value, '%', parsed.W_USED_MEMORY_PEAK_PERCENTAGE, parsed.C_USED_MEMORY_PEAK_PERCENTAGE, 0, 100)
    submsg += '\n* used_memory_peak_percentage: {} {}'.format(used_memory_peak_percentage_value, state_to_string(used_memory_percentage_state))

    used_memory_rss_state = evaluate_greater(result['used_memory_rss'], parsed.W_USED_MEMORY_RSS, parsed.C_USED_MEMORY_RSS)
    overall_state = get_greater_state(overall_state, used_memory_rss_state)
    perfdata += unpack_perfdata('used_memory_rss', result['used_memory_rss'], None, parsed.W_USED_MEMORY_RSS, parsed.C_USED_MEMORY_RSS, 0, None)
    submsg += '\n* used_memory_rss: {} {}'.format(result['used_memory_rss_human'], state_to_string(mem_fragmentation_ratio_state))

    submsg += '\n\nPersistence'

    rdb_changes_since_last_save_state = evaluate_greater(result['rdb_changes_since_last_save'], parsed.W_RDB_CHANGES_SINCE_LAST_SAVE, parsed.C_RDB_CHANGES_SINCE_LAST_SAVE)
    overall_state = get_greater_state(overall_state, rdb_changes_since_last_save_state)
    perfdata += unpack_perfdata('rdb_changes_since_last_save', result['rdb_changes_since_last_save'], None, parsed.W_RDB_CHANGES_SINCE_LAST_SAVE, parsed.C_RDB_CHANGES_SINCE_LAST_SAVE, 0, None)
    submsg += '\n* rdb_changes_since_last_save: {} {}'.format(result['rdb_changes_since_last_save'], state_to_string(rdb_changes_since_last_save_state))

    rdb_last_save_time_datetime = datetime.datetime.fromtimestamp(float(result['rdb_last_save_time']))
    rdb_last_save_time_state = evaluate_greater_datetime_to_now(rdb_last_save_time_datetime, parsed.W_RDB_LAST_SAVE_TIME, parsed.C_RDB_LAST_SAVE_TIME) # todo
    overall_state = get_greater_state(overall_state, rdb_last_save_time_state)
    perfdata += unpack_perfdata('rdb_last_save_time', result['rdb_last_save_time'], None, parsed.W_RDB_LAST_SAVE_TIME, parsed.C_RDB_LAST_SAVE_TIME, 0, None)
    submsg += '\n* rdb_last_save_time: {} {}'.format(unix_time_to_iso(result['rdb_last_save_time']), state_to_string(rdb_last_save_time_state))

    submsg += '\n\nClients'

    blocked_clients_state = evaluate_greater(result['blocked_clients'], parsed.W_BLOCKED_CLIENTS, parsed.C_BLOCKED_CLIENTS)
    overall_state = get_greater_state(overall_state, blocked_clients_state)
    perfdata += unpack_perfdata('blocked_clients', result['blocked_clients'], None, parsed.W_BLOCKED_CLIENTS, parsed.C_BLOCKED_CLIENTS, 0, None)
    submsg += '\n* blocked_clients: {} {}'.format(result['blocked_clients'], state_to_string(blocked_clients_state))

    connected_clients_state = evaluate_greater(result['connected_clients'], parsed.W_CONNECTED_CLIENTS, parsed.C_CONNECTED_CLIENTS)
    overall_state = get_greater_state(overall_state, connected_clients_state)
    perfdata += unpack_perfdata('connected_clients', result['connected_clients'], None, parsed.W_CONNECTED_CLIENTS, parsed.C_CONNECTED_CLIENTS, 0, None)
    submsg += '\n* connected_clients: {} {}'.format(result['connected_clients'], state_to_string(connected_clients_state))

    submsg += '\n\nStats'

    evicted_keys_state = evaluate_greater(result['evicted_keys'], parsed.W_EVICTED_KEYS, parsed.C_EVICTED_KEYS)
    overall_state = get_greater_state(overall_state, evicted_keys_state)
    perfdata += unpack_perfdata('evicted_keys', result['evicted_keys'], None, parsed.W_EVICTED_KEYS, parsed.C_EVICTED_KEYS, 0, None)
    submsg += '\n* evicted_keys: {} {}'.format(result['evicted_keys'], state_to_string(evicted_keys_state))

    rejected_connections_state = evaluate_greater(result['rejected_connections'], parsed.W_REJECTED_CONNECTIONS, parsed.C_REJECTED_CONNECTIONS)
    overall_state = get_greater_state(overall_state, rejected_connections_state)
    perfdata += unpack_perfdata('rejected_connections', result['rejected_connections'], None, parsed.W_REJECTED_CONNECTIONS, parsed.C_REJECTED_CONNECTIONS, 0, None)
    submsg += '\n* rejected_connections: {} {}'.format(result['rejected_connections'], state_to_string(rejected_connections_state))

    submsg += '\n\nReplication'
    submsg +='\n* role: {}'.format(result['role'])

    connected_slaves_state = evaluate_greater(result['connected_slaves'], parsed.W_CONNECTED_SLAVES, parsed.C_CONNECTED_SLAVES)
    overall_state = get_greater_state(overall_state, connected_slaves_state)
    perfdata += unpack_perfdata('connected_slaves', result['connected_slaves'], None, parsed.W_CONNECTED_SLAVES, parsed.C_CONNECTED_SLAVES, 0, None)
    submsg += '\n* connected_slaves: {} {}'.format(result['connected_slaves'], state_to_string(connected_slaves_state))

    submsg += '\n\nLinux Server Configuration'
    with open('/proc/sys/net/core/somaxconn') as file:
        somaxconn_value = int(file.readline())
        somaxconn_state = evaluate_greater(somaxconn_value, SOMAXCONN_WARN, SOMAXCONN_CRIT)
        overall_state = get_greater_state(overall_state, somaxconn_state)
        submsg += '\n* /proc/sys/net/core/somaxconn: {} {}'.format(somaxconn_value, state_to_string(somaxconn_state))

    with open('/proc/sys/vm/overcommit_memory') as file:
        overcommit_memory_value = int(file.readline())
        overcommit_memory_state = STATE_OK if overcommit_memory_value == OVERCOMMIT_MEMORY_EXPECTED_VALUE else STATE_WARN
        overall_state = get_greater_state(overall_state, overcommit_memory_state)
        submsg += '\n* /proc/sys/vm/overcommit_memory: {} {}'.format(overcommit_memory_value, state_to_string(overcommit_memory_state))

    with open('/sys/kernel/mm/transparent_hugepage/enabled') as file:
        transparent_hugepage_value = file.readline().strip()
        transparent_hugepage_state = STATE_OK if transparent_hugepage_value == TRANSPARENT_HUGEPAGE_EXPECTED_VALUE else STATE_WARN
        overall_state = get_greater_state(overall_state, transparent_hugepage_state)
        submsg += '\n* /sys/kernel/mm/transparent_hugepage/enabled: {} {}'.format(transparent_hugepage_value, state_to_string(transparent_hugepage_state))

    if overall_state == STATE_OK:
        msg = 'Everything is ok. (Role: {})\n{}'.format(result['role'], submsg)
    else:
        msg = 'One or more errors. (Role: {})\n{}'.format(result['role'], submsg)
    print(msg.strip() + '|' + perfdata.strip())
    exit(overall_state)
    
main()
