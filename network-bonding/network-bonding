#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

import argparse
import sys
from traceback import print_exc

from lib.globals import STATE_OK, STATE_UNKNOWN, STATE_WARN, STATE_CRIT
import lib.args
import lib.base

__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020060101'

DESCRIPTION = '''Reports the state of a channel bonding interface. Channel bonding enables two or
    more network interfaces to act as one, simultaneously increasing the bandwidth and providing
    redundancy.'''

DEFAULT_BOND = 'bond0'
CMD1 = 'ls /proc/net/bonding/'
CMD2 = 'cat /proc/net/bonding/{}'


def parse_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V', '--version',
        action='version',
        version='%(prog)s: v{} by {}'.format(__version__, __author__)
        )

    parser.add_argument(
        '--always-ok',
        help='Always returns OK.',
        dest='ALWAYS_OK',
        action='store_true',
        default=False,
        )

    parser.add_argument(
        '--test',
        help='For unit tests. Needs "path-to-stdout-file,path-to-stderr-file,expected-retc".',
        dest='TEST',
        type=lib.args.csv,
        )

    return parser.parse_args()


def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit as e:
        sys.exit(STATE_UNKNOWN)

    if args.TEST is None:
        lib.base.oao('Has to be done.', STATE_OK)
    else:
        # do not call the command, put in test data
        result, stderr, retc = lib.base.test(args.TEST)

    if not result:
        lib.base.oao('No bonding interfaces found.', STATE_UNKNOWN)

    msg = ''
    state = STATE_OK

    # now, check the media-independent interface status (MII)
    in_interface_section = False
    for row in result.splitlines():
        if not row:
            # empty line after the end of an interface section
            if in_interface_section and mii_status != 'up':
                msg = '{} is {} with {} link {}.'.format(
                    slave_interface,
                    mii_status,
                    link_failure_count,
                    lib.base.pluralize('failure', link_failure_count))
                state = STATE_WARN
                in_interface_section = False
            continue
        if ': ' not in row:
            continue
        print(row)
        key, value = row.split(': ')
        if key == 'Bonding Mode':
            bonding_mode = value
        if key == 'Link Failure Count':
            link_failure_count = value
        if key == 'MII Status':
            mii_status = value
        if key == 'Slave Interface':
            slave_interface = value
            in_interface_section = True

    print(msg, bonding_mode, link_failure_count, mii_status, slave_interface)
    exit()

    # get the values
    value = 50

    # get the state
    state = lib.base.get_state(value, args.WARN, args.CRIT, operator='ge')

    # create perfdata
    perfdata = ''
    perfdata += lib.base.get_perfdata('label', value, '%', args.WARN, args.CRIT, 0, 100)

    lib.base.oao(msg, state, perfdata, always_ok=args.ALWAYS_OK)


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print_exc()
        sys.exit(STATE_UNKNOWN)
