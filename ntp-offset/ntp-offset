#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md


__author__  = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020040701'

DESCRIPTION = 'This plugin checks the clock offset with the ntp server.'

systemctl_command = 'systemctl is-active --quiet {service}' # ntpd / chronyd
command_installed = 'command -v {program}'                  # ntpq / chronyc

ntpq_command = 'ntpq -p'
chronyc_command = 'chronyc tracking'

DEFAULT_WARN = 800
DEFAULT_CRIT = 1001


#====================
from lib.globals import *

import lib.base

import argparse
from traceback import print_exc


def parse_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument('-V', '--version',
        action = 'version',
        version = '{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
        )

    parser.add_argument('-c', '--critical',
        help='Set the critical threshold for the ntp time offset, in ms. Default: %(default)sms',
        dest='CRIT',
        type = int,
        default = DEFAULT_CRIT,
        )
    
    parser.add_argument('-w', '--warning',
        help='Set the warning threshold for the ntp time offset, in ms. Default: %(default)sms',
        dest='WARN',
        type = int,
        default = DEFAULT_WARN,
        )

    return parser.parse_args()


def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit as e:
        exit(STATE_UNKNOWN)

    # execute the shell command and return its result and exit code
    formatted_systemctl_command = systemctl_command.format(service='ntpd')
    stdout, stderr, retc = lib.base.shell_exec(formatted_systemctl_command)
    if (stderr):
        print('Bash command `{}` failed.'.format(formatted_systemctl_command))
        print('Stdout: {}\nStderr: {}'.format(stdout, stderr))
        exit(STATE_UNKNOWN)
    ntpd_present = True if retc == 0 else False

    # execute the shell command and return its result and exit code
    formatted_systemctl_command = systemctl_command.format(service='chronyd')
    stdout, stderr, retc = lib.base.shell_exec(formatted_systemctl_command)
    if (stderr):
        print('Bash command `{}` failed.'.format(formatted_systemctl_command))
        print('Stdout: {}\nStderr: {}'.format(stdout, stderr))
        exit(STATE_UNKNOWN)
    chronyd_present = True if retc == 0 else False

    if ntpd_present == False and chronyd_present == False:
        lib.base.oao('Neither ntpd nor chronyd found.', STATE_UNKNOWN)

    if ntpd_present:
        formatted_command_installed = command_installed.format(program='ntpq')
        # check if shell command is available
        stdout, stderr, retc = lib.base.shell_exec(formatted_command_installed)
        if (retc != 0):
            lib.base.oao('"ntpq" is missing.', STATE_UNKNOWN)

        # execute the shell command and return its result and exit code
        stdout, stderr, retc = lib.base.shell_exec(ntpq_command)
        if (stderr): # todo check retc?
            print('Bash command `{}` failed.'.format(ntpq_command))
            print('Stdout: {}\nStderr: {}'.format(stdout, stderr))
            exit(STATE_UNKNOWN)
        msg_body = stdout

        ntp_server_found = False
        for line in msg_body.splitlines():
            line = line.strip()
            if line.startswith('*'):
                ntp_server_found = True
                line = line[1:].split()  # remove '*' and split
                ntp_server = line[0]
                offset = float(line[8])
                stratum = int(line[2])

        if not ntp_server_found:
            lib.base.oao('No NTP server used.', STATE_UNKNOWN)

    if chronyd_present:
        formatted_command_installed = command_installed.format(program='chronyc')
        # check if shell command is available
        stdout, stderr, retc = lib.base.shell_exec(formatted_command_installed)
        if (retc != 0):
            lib.base.oao('"chronyc" is missing.', STATE_UNKNOWN)

        # execute the shell command and return its result and exit code
        stdout, stderr, retc = lib.base.shell_exec(chronyc_command)
        if (stderr): # todo check retc?
            print('Bash command `{}` failed.'.format(chronyc_command))
            print('Stdout: {}\nStderr: {}'.format(stdout, stderr))
            exit(STATE_UNKNOWN)
        msg_body = stdout

        for line in msg_body.splitlines():
            line = line.strip()
            if line.startswith('Reference ID'):
                ntp_server = line[line.find("(")+1:line.find(")")] # extract text in () using string splicing
                continue

            if line.startswith('Last offset'):
                offset = float(line.split()[-2]) * 1000
                continue

            if line.startswith('Stratum'):
                stratum = int(line.split()[-1])
                continue

    if ntp_server == '':
        lib.base.oao('No NTP server found.', STATE_UNKNOWN)

    if ntp_server == 'LOCAL':
        lib.base.oao('No NTP server used.', STATE_UNKNOWN)

    perfdata = lib.base.get_perfdata('offset', offset, 'ms', args.WARN, args.CRIT, None, None)

    if abs(offset) >= args.CRIT:
        msg_header = 'NTP offset too low/high. Offset is {0}ms.'.format(offset)
        lib.base.oao(msg_header + '\n' + msg_body, STATE_CRIT, perfdata)

    if abs(offset) >= args.WARN:
        msg_header = 'NTP offset too low/high. Offset is {0}ms.'.format(offset)
        lib.base.oao(msg_header + '\n' + msg_body, STATE_WARN, perfdata)

    if stratum >= 9:
        msg_header = 'Stratum {0} is >= 9. NTP offset {1}.'.format(stratum, offset)
        lib.base.oao(msg_header + '\n' + msg_body, STATE_WARN, perfdata)

    msg_header = 'NTP offset is {0}ms (Stratum {1}).'.format(offset, stratum)
    lib.base.oao(msg_header + '\n' + msg_body, STATE_OK, perfdata)


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print_exc()
        exit(STATE_UNKNOWN)
