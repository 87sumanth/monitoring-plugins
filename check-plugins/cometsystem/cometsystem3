#!/usr/bin/env python3
# -*- coding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://github.com/Linuxfabrik/monitoring-plugins/blob/main/CONTRIBUTING.rst

"""See the check's README for more details.
"""

import argparse # pylint: disable=C0413
import sys # pylint: disable=C0413
import json # pylint: disable=C0413

import lib.args3  # pylint: disable=C0413
import lib.base3  # pylint: disable=C0413
import lib.url3   # pylint: disable=C0413
import lib.test3  # pylint: disable=C0413
import lib.time3  # pylint: disable=C0413
from lib.globals3 import (STATE_CRIT, STATE_OK,  # pylint: disable=C0413
                          STATE_UNKNOWN, STATE_WARN)


__author__ = """Linuxfabrik GmbH, Zurich/Switzerland;
                originally written by Dominik Riva, Universitätsspital Basel/Switzerland"""
__version__ = '2022121201'

DESCRIPTION = """This check targets the JSON endpoint of https://www.cometsystem.com/ Web Sensors.
                 Alert states can be set per measurements low and high threshold violations."""

DEFAULT_HIGH = 'CRITICAL'
DEFAULT_INSECURE = False
DEFAULT_LOW = 'WARNING'
DEFAULT_NO_PROXY = False
DEFAULT_TIMEOUT = 3
DEFAULT_PERFDATA = False
DEFAULT_CHANNELS = ["ch1", "ch2", "ch3"]


def parse_args():
    """Parse command line arguments using argparse.
    """
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V', '--version',
        action='version',
        version='%(prog)s: v{} by {}'.format(__version__, __author__)
    )

    parser.add_argument(
        '--always-ok',
        help='Always returns OK.',
        dest='ALWAYS_OK',
        action='store_true',
        default=False,
    )

    parser.add_argument(
        '--channels',
        help='Comma separated channels one per sensor. Default: %(default)s',
        dest='CHANNELS',
        default=DEFAULT_CHANNELS,
        type=lib.args3.csv,
    )

    parser.add_argument(
        '--high',
        help='Comma separated states [OK,CRITICAL,WARNING] per sensor value. '
             'If only one state is provided it gets applied to all high '
             'threshold violations. Default: %(default)s',
        dest='HIGH',
        default=DEFAULT_HIGH,
        type=lib.args3.csv,
    )

    parser.add_argument(
        '--insecure',
        help='This option explicitly allows to perform "insecure"'
        ' SSL connections. Default: %(default)s',
        dest='INSECURE',
        action='store_true',
        default=DEFAULT_INSECURE,
    )

    parser.add_argument(
        '--low',
        help='Comma separated states [OK,CRITICAL,WARNING] per sensor value. '
             'If only one state is provided it gets applied to all low '
             'threshold violations. Default: %(default)s',
        dest='LOW',
        default=DEFAULT_LOW,
        type=lib.args3.csv,
    )

    parser.add_argument(
        '--no-proxy',
        help='Do not use a proxy. Default: %(default)s',
        dest='NO_PROXY',
        action='store_true',
        default=DEFAULT_NO_PROXY,
    )

    parser.add_argument(
        '--perfdata',
        help='send perfdata. Default: %(default)s',
        dest='PERFDATA',
        action='store_true',
        default=DEFAULT_PERFDATA,
    )

    parser.add_argument(
        '--test',
        help='For unit tests. Needs "path-to-stdout-file,path-to-stderr-file,expected-retc".',
        dest='TEST',
        type=lib.args3.csv,
    )

    parser.add_argument(
        '--timeout',
        help='Network timeout in seconds. Default: %(default)s (seconds)',
        dest='TIMEOUT',
        type=int,
        default=DEFAULT_TIMEOUT,
    )

    parser.add_argument(
        '-u', '--url',
        help='Set the URL of the values as JSON.  http://example.com/values.json',
        dest='URL',
        required=True,
    )

    return parser.parse_args()


def main():
    """The main function. Hier spielt die Musik.
    """

    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit:
        sys.exit(STATE_UNKNOWN)

    if len(args.HIGH) > 1 and not len(args.HIGH) == len(args.CHANNELS):
        lib.base3.oao('--high parameter doesn\'t match --channel length', STATE_UNKNOWN)
    if len(args.LOW) > 1 and not len(args.LOW) == len(args.CHANNELS):
        lib.base3.oao('--low parameter doesn\'t match --channel length', STATE_UNKNOWN)

    # fetch data
    if args.TEST is None:
        URL = args.URL
        if URL[0:4] != 'http':
            lib.base3.oao('--url parameter has to start with "http://" or https://".', STATE_UNKNOWN)
        # fetch the URL
        result = lib.base3.coe(lib.url3.fetch_json(
            URL,
            insecure=args.INSECURE,
            no_proxy=args.NO_PROXY,
            timeout=args.TIMEOUT,
        ))
        if 'ch1' not in result:
            lib.base3.oao('Malformed Web Sensors status file.', STATE_UNKNOWN)
    else:
        # do not call the command, put in test data
        stdout, stderr, retc = lib.test3.test(args.TEST)
        result = json.loads(stdout)

    # init some vars
    msg = ''
    state = STATE_OK
    perfdata = ''
    alarm_reason = ''
    alarm_name = ''
    alarm_value = ''
    alarm_unit = ''

    # analyze data
    i = 0
    for ch in args.CHANNELS:
        #print(j[ch]["name"]+": "+j[ch]["aval"]+j[ch]["unit"])
        name = result[ch]['name']
        unit = result[ch]['unit'].replace('\udcb0', '°')#.decode("ISO-8859-1")
        value = result[ch]['aval']
        alarm = result[ch]['alarm']
        if len(args.HIGH) > 1:
            high = args.HIGH[i]
        else:
            high = args.HIGH[0]
        if len(args.LOW) > 1:
            low = args.LOW[i]
        else:
            low = args.LOW[0]
        if alarm == 0:
            """ no alarm """
            ch_state = STATE_OK
        if alarm == 1:
            """ high alarm """
            ch_state = lib.base3.str2state(high, ignore_error=False)
        if alarm == 2:
            """ low alarm """
            ch_state = lib.base3.str2state(low, ignore_error=False)
        reason = ['', ' high', ' low'][alarm]
        if ch_state > state or i == 0:
            """ get worst state or fist channel in hope that it is most important """
            state = ch_state
            alarm_reason = reason
            alarm_type = alarm
            alarm_name = name
            alarm_value = value
            alarm_unit = unit
            alarm_ch = ch
        msg += '\n{} = {} {} {}{} {}'.format(
            ch,
            name,
            value,
            unit,
            reason,
            lib.base3.state2str(ch_state)
        )
        if args.PERFDATA:
            if '%' in unit:
                perfdata += lib.base3.get_perfdata(name, value, '%', _min=0, _max=100)
            elif '°' in unit:
                unit = unit[-1]
                if unit == 'C':
                    perfdata += lib.base3.get_perfdata(name, value, unit, _min=-60, _max=80)
                elif unit == 'F':
                    perfdata += lib.base3.get_perfdata(name, value, unit, _min=-20, _max=176)
                else:
                    perfdata += lib.base3.get_perfdata(name, value, unit,)
            else:
                perfdata += lib.base3.get_perfdata(name, value, unit,)
        i = i + 1


    prefix_msg = '{}{}{}: {} {}'.format(
        lib.base3.state2str(state, suffix=' '),
        alarm_name,
        alarm_reason,
        alarm_value,
        alarm_unit
    )
    msg = prefix_msg + msg


    # over and out
    lib.base3.oao(msg, state, perfdata, always_ok=args.ALWAYS_OK)


if __name__ == '__main__':
    try:
        main()
    except Exception:   # pylint: disable=W0703
        lib.base3.cu()
