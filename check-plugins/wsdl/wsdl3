#! /usr/bin/env python3
# -*- coding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

"""Have a look at the check's README for further details
"""

import os

# considering a virtual environment
ACTIVATE_THIS = False
venv_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'monitoring-plugins-venv3')
if os.path.exists(venv_path):
    ACTIVATE_THIS = os.path.join(venv_path, 'bin/activate_this.py')

if os.getenv('MONITORING_PLUGINS_VENV3'):
    ACTIVATE_THIS = os.path.join(os.getenv('MONITORING_PLUGINS_VENV3') + 'bin/activate_this.py')

if ACTIVATE_THIS and os.path.isfile(ACTIVATE_THIS):
    exec(open(ACTIVATE_THIS).read(), {'__file__': ACTIVATE_THIS}) # pylint: disable=W0122


import argparse # pylint: disable=C0413
import base64 # pylint: disable=C0413
import sys # pylint: disable=C0413

import lib.base3 # pylint: disable=C0413
import lib.url3 # pylint: disable=C0413
import lxml.etree
from lib.globals3 import STATE_CRIT, STATE_OK, STATE_UNKNOWN, STATE_WARN # pylint: disable=C0413


__author__ = """Linuxfabrik GmbH, Zurich/Switzerland;
                originally written by Simon Wunderlin and adapted by Dominik Riva, Universit√§tsspital Basel/Switzerland"""
__version__ = '2022050401'


DESCRIPTION = """This plugin checks for a matching string in the XML response after a basic auth to a WSDL URL."""

DEFAULT_TIMEOUT = 5
DEFAULT_NO_PROXY = False


def parse_args():
	"""Parse command line agruments using argparse.
	"""
	parser = argparse.ArgumentParser(description=DESCRIPTION)

	parser.add_argument(
		'--always-ok',
		help='Always return OK.',
		dest='ALWAYS_OK',
		action='store_true',
		default=False,
	)

	parser.add_argument(
		'-V', '--version',
		action='version',
		version='{0}: v{1} by v{2}'.format('%(prog)s', __version__, __author__)
	)

	parser.add_argument(
		'--no-proxy',
		help='Do not use a proxy. Default: %(default)s',
		dest='NO_PROXY',
		action='store_true',
		default=DEFAULT_NO_PROXY,
	)

	parser.add_argument(
		'--service-url',
		help='http/https url to WSDL',
		dest='service_url',
		required=True,
	)

	parser.add_argument(
		'--service-user',
		help='http/https user name for basic auth',
		dest='service_user',
		required=True,
	)

	parser.add_argument(
		'--service-pass',
		help='http/https password for basic auth',
		dest='service_pass',
		required=True,
	)

	parser.add_argument(
		'--timeout',
		help='Network timeout in seconds. Default: %(default)s (seconds)',
		dest='TIMEOUT',
		type=int,
		default=DEFAULT_TIMEOUT,
	)

	parser.add_argument(
		'--expect',
		help='The value we expect to find in the expath''s location',
		dest='expect',
		required=True,
	)

	parser.add_argument(
		'--xpath',
		help='XPath query to compare with --expect. The result must point to a single value (attribute or node content). Lists/arrays are not supported.',
		dest='xpath',
		required=True,
	)

	return parser.parse_args()

def main():
	try:
		args = parse_args()
	except SystemExit:
		sys.exit(STATE_UNKNOWN)

	header = {
		"Accept": "application/xml",
		"Connection": "keep-alive",
		"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36",
	}

	auth = '{}:{}'.format(args.service_user, args.service_pass)
	encoded_auth = lib.txt3.to_text(base64.b64encode(lib.txt3.to_bytes(auth)))
	header['Authorization'] = 'Basic {}'.format(encoded_auth)

	result = lib.base3.coe(lib.url3.fetch(
		args.service_url,
		header=header,
		no_proxy=args.NO_PROXY,
		timeout=args.TIMEOUT
	))

	# parse result
	val = None
	try:
		ns = {"wsdl": "http://schemas.xmlsoap.org/wsdl/"}
		root = lxml.etree.fromstring(bytes(result, encoding='utf8'))
	except Exception as e:
		msg = "[CRITICAL] Failed to parse response XML"
		state = STATE_CRIT
		lib.base3.oao(msg, state=state, always_ok=args.ALWAYS_OK)

	try:
		val = root.xpath(args.xpath, namespaces=ns)[0]
	except Exception as e:
		msg = "[CRITICAL] Failed to search response XML, no match found."
		state = STATE_CRIT
		lib.base3.oao(msg, state=state, always_ok=args.ALWAYS_OK)

	if val != args.expect:
		msg = "[CRITICAL] Result '{}' doesn't match '{}'".format(val, args.expect)
		state = STATE_CRIT
	else:
		msg = "[OK] expected match found"
		state = STATE_OK

	# over and out
	lib.base3.oao(
		msg,
		state,
		always_ok=args.ALWAYS_OK)

if __name__ == '__main__':
	try:
		sys.exit(main())
	except Exception:   # pylint: disable=W0703
		lib.base3.cu()
