#! /usr/bin/env python3
# -*- coding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

"""Have a look at the check's README for further details.
"""

import os

# considering a virtual environment
ACTIVATE_THIS = False
venv_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'monitoring-plugins-venv3')
if os.path.exists(venv_path):
    ACTIVATE_THIS = os.path.join(venv_path, 'bin/activate_this.py')

if os.getenv('MONITORING_PLUGINS_VENV3'):
    ACTIVATE_THIS = os.path.join(os.getenv('MONITORING_PLUGINS_VENV3') + 'bin/activate_this.py')

if ACTIVATE_THIS and os.path.isfile(ACTIVATE_THIS):
    exec(open(ACTIVATE_THIS).read(), {'__file__': ACTIVATE_THIS}) # pylint: disable=W0122


import argparse # pylint: disable=C0413
from collections import defaultdict # pylint: disable=C0413
import sys # pylint: disable=C0413
from traceback import print_exc # pylint: disable=C0413

import lib.base3 # pylint: disable=C0413
from lib.globals3 import STATE_CRIT, STATE_OK, STATE_UNKNOWN, STATE_WARN # pylint: disable=C0413

try:
    import psutil # pylint: disable=C0413
except ImportError:
    print('Python module "psutil" is not installed.')
    sys.exit(STATE_UNKNOWN)


__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2021061001'

DESCRIPTION = """Checks the number of currently running processes and warns on process counts or 
                process memory usage."""

DEFAULT_CRIT = None
DEFAULT_WARN = None
DEFAULT_CRIT_MEM = None
DEFAULT_WARN_MEM = None


def parse_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
    )

    parser.add_argument(
        '--always-ok',
        help='Always returns OK.',
        dest='ALWAYS_OK',
        action='store_true',
        default=False,
    )

    parser.add_argument(
        '--argument',
        help='Only scan for processes containing ARGUMENT in the command, for example `-s` (case-insensitive).',
        dest='ARGUMENT',
    )

    parser.add_argument(
        '--command',
        help='Only scan for processes starting with COMMAND, for example `bash` (without path, case-insensitive).',
        dest='COMMAND',
    )

    parser.add_argument(
        '-c', '--critical',
        help='Set the critical threshold for the number of processes (none, range or int). Default: %(default)s',
        default=DEFAULT_CRIT,
        dest='CRIT',
    )

    parser.add_argument(
        '--critical-mem',
        help='Set the critical threshold Memory Usage in bytes. Default: %(default)s',
        default=DEFAULT_CRIT_MEM,
        dest='CRIT_MEM',
    )

    parser.add_argument(
        '--no-kthreads',
        help='Only scan for non kernel threads (works on Linux only). Default: %(default)s.',
        dest='NO_KTHREADS',
        action='store_true',
        default=False,
    )

    parser.add_argument(
        '--username',
        help='Only scan for processes with user name, for example `apache` (case-insensitive).',
        dest='USERNAME',
    )

    parser.add_argument(
        '-w', '--warning',
        help='Set the warning threshold for the number of processes (none, range or int). Default: %(default)s',
        dest='WARN',
        default=DEFAULT_WARN,
    )

    parser.add_argument(
        '--warning-mem',
        help='Set the warning threshold Memory Usage in bytes. Default: %(default)s',
        default=DEFAULT_WARN_MEM,
        dest='WARN_MEM',
    )

    return parser.parse_args()


def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit:
        sys.exit(STATE_UNKNOWN)

    # init some vars
    kthreadd_pid = 0
    mem_sum = 0
    my_pid = os.getpid()
    proc_states = defaultdict(lambda : 0)
    cnt = 0
    uninterruptibles = running = zombies = {}

    processes = psutil.process_iter()
    for process in processes:
        try:
            process_info = process.as_dict(attrs=['cmdline', 'name', 'status', 'memory_info', 'username', 'ppid'])
        except:
            # process no longer exists 
            continue

        # always ignore myself
        if process.pid == my_pid:
            continue

        # only scan for processes for user name (if set)
        if args.USERNAME and process_info['username'].lower() != args.USERNAME.lower():
            continue

        # only scan for processes starting with command name (if set)
        if args.COMMAND and not process_info['name'].lower().startswith(args.COMMAND.lower()):
            continue

        # only scan for processes with arguments (if set)
        if args.ARGUMENT and not args.ARGUMENT.lower() in ' '.join(process_info['cmdline']).lower():
            continue

        # filter kernel threads (childs of KTHREAD_PARENT)
        if args.NO_KTHREADS:
            if process_info['name'] == 'kthreadd':
                kthreadd_pid = process.pid
            else:
                if kthreadd_pid and process_info['ppid'] == kthreadd_pid:
                    continue

        cnt += 1

        # aka "Resident Set Size", this is the non-swapped physical memory a process has used.
        # * On UNIX it matches "top"`s RES column.
        # * On Windows this is an alias for wset field and it matches "Mem Usage" column of taskmgr.exe.
        mem_sum += process_info['memory_info'].rss

        proc_states[process_info['status']] += 1

        if process_info['status'] == psutil.STATUS_DISK_SLEEP:  # == uninterruptible
            name = process_info['name']
            if name in uninterruptibles:
                uninterruptibles[name] += 1
            else:
                uninterruptibles[name] = 1

        if process_info['status'] == psutil.STATUS_RUNNING:
            name = process_info['name']
            if name in running:
                running[name] += 1
            else:
                running[name] = 1

        if process_info['status'] == psutil.STATUS_ZOMBIE:
            name = process_info['name'].replace(' <defunct>', '')
            if name in zombies:
                zombies[name] += 1
            else:
                zombies[name] = 1

    # group some proc_states, have a look at the README for details
    proc_states[psutil.STATUS_SLEEPING] += proc_states[psutil.STATUS_IDLE]
    del proc_states[psutil.STATUS_IDLE]
    proc_states[psutil.STATUS_STOPPED] += proc_states[psutil.STATUS_TRACING_STOP]
    del proc_states[psutil.STATUS_TRACING_STOP]

    # build the state, check the ranges
    if not lib.base3.coe(lib.base3.match_range(cnt, args.CRIT)):
        state = STATE_CRIT
    elif not lib.base3.coe(lib.base3.match_range(cnt, args.WARN)):
        state = STATE_WARN
    else:
        state = STATE_OK

    if not lib.base3.coe(lib.base3.match_range(mem_sum, args.CRIT_MEM)):
        mem_state = STATE_CRIT
    elif not lib.base3.coe(lib.base3.match_range(mem_sum, args.WARN_MEM)):
        mem_state = STATE_WARN
    else:
        mem_state = STATE_OK
    state = lib.base3.get_worst(state, mem_state)

    # build the message
    msg = '{} {} using '.format(cnt, lib.base3.pluralize('proc', cnt))
    msg += '{} mem '.format(lib.base3.bytes2human(mem_sum))

    msg_param = ''
    if args.USERNAME:
        msg_param += 'user {}, '.format(args.USERNAME)
    if args.COMMAND:
        msg_param += 'cmd {}, '.format(args.COMMAND)
    if args.ARGUMENT:
        msg_param += 'args {}, '.format(args.ARGUMENT)
    if args.NO_KTHREADS:
        msg_param += 'w/o kthreads, '.format(args.COMMAND)
    if msg_param:
        msg += '(filter: {}) '.format(msg_param[:-2])

    msg += '- '

    if proc_states[psutil.STATUS_DEAD]:
        msg += '{} dead, '.format(proc_states[psutil.STATUS_DEAD])

    if proc_states[psutil.STATUS_RUNNING]:
        msg += '{} running ('.format(proc_states[psutil.STATUS_RUNNING])
        for name, count in running.items():
            msg += '{}x {}, '.format(count, name)
        msg = msg[:-2]
        msg += '), '

    if proc_states[psutil.STATUS_SLEEPING]:
        msg += '{} sleeping, '.format(proc_states[psutil.STATUS_SLEEPING])

    if proc_states[psutil.STATUS_STOPPED]:
        msg += '{} stopped, '.format(proc_states[psutil.STATUS_STOPPED])

    if proc_states[psutil.STATUS_DISK_SLEEP]:
        msg += '{} {} ('.format(proc_states[psutil.STATUS_DISK_SLEEP], lib.base3.pluralize('uninterruptible', proc_states[psutil.STATUS_DISK_SLEEP]))
        for name, count in uninterruptibles.items():
            msg += '{}x {}, '.format(count, name)
        msg = msg[:-2]
        msg += '), '

    if proc_states[psutil.STATUS_ZOMBIE]:
        msg += '{} {} ('.format(proc_states[psutil.STATUS_ZOMBIE], lib.base3.pluralize('zombie', proc_states[psutil.STATUS_ZOMBIE]))
        for name, count in zombies.items():
            msg += '{}x {}, '.format(count, name)
        msg = msg[:-2]
        msg += '), '

    # build perfdata
    perfdata = ''
    perfdata += lib.base3.get_perfdata('procs', cnt, None, args.WARN, args.CRIT, 0, None)
    perfdata += lib.base3.get_perfdata('procs_sleeping', proc_states[psutil.STATUS_SLEEPING], None, None, None, 0, None)
    perfdata += lib.base3.get_perfdata('procs_running', proc_states[psutil.STATUS_RUNNING], None, None, None, 0, None)
    perfdata += lib.base3.get_perfdata('procs_uninterruptible', proc_states[psutil.STATUS_DISK_SLEEP], None, None, None, 0, None)
    perfdata += lib.base3.get_perfdata('procs_zombies', proc_states[psutil.STATUS_ZOMBIE], None, None, None, 0, None)
    perfdata += lib.base3.get_perfdata('procs_stopped', proc_states[psutil.STATUS_STOPPED], None, None, None, 0, None)
    perfdata += lib.base3.get_perfdata('procs_dead', proc_states[psutil.STATUS_DEAD], None, None, None, 0, None)
    perfdata += lib.base3.get_perfdata('procs_mem', mem_sum, None, args.WARN_MEM, args.CRIT_MEM, 0, None)

    # over and out
    lib.base3.oao(msg[:-2], state, perfdata, always_ok=args.ALWAYS_OK)


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print_exc()
        sys.exit(STATE_UNKNOWN)
