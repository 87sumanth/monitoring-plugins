#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

import os

activate_this = False
venv_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'monitoring-plugins-venv2')
if os.path.exists(venv_path):
    activate_this = os.path.join(venv_path, 'bin/activate_this.py')

if os.getenv('MONITORING_PLUGINS_VENV2'):
    activate_this = os.path.join(os.getenv('MONITORING_PLUGINS_VENV2') + 'bin/activate_this.py')

if activate_this and os.path.isfile(activate_this):
    exec(open(activate_this).read(), {'__file__': activate_this})


import argparse
import sys
import time
from traceback import print_exc
from collections import defaultdict

import lib.base2
from lib.globals2 import STATE_OK, STATE_WARN, STATE_CRIT, STATE_UNKNOWN

try:
    import psutil
except ImportError as e:
    print('Python module "psutil" is not installed.')
    sys.exit(STATE_UNKNOWN)


__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2021021801'

DESCRIPTION = 'Checks the number of currently running processes and warns on process counts or zombie process states.'

DEFAULT_CRIT = None
DEFAULT_WARN = None
DEFAULT_CRIT_CPU = None
DEFAULT_WARN_CPU = None
DEFAULT_CRIT_MEM = None
DEFAULT_WARN_MEM = None


def parse_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
    )

    parser.add_argument(
        '--always-ok',
        help='Always returns OK.',
        dest='ALWAYS_OK',
        action='store_true',
        default=False,
    )

    parser.add_argument(
        '--argument',
        help='Only scan for processes containing ARGUMENT in the command.',
        dest='ARGUMENT',
    )

    parser.add_argument(
        '--command',
        help='Only scan for processes starting with COMMAND (without path).',
        dest='COMMAND',
    )

    parser.add_argument(
        '-c', '--critical',
        help='Set the critical threshold for the number of processes (none, range or int). Default: %(default)s',
        default=DEFAULT_CRIT,
        dest='CRIT',
    )

    parser.add_argument(
        '--critical-cpu',
        help='Set the critical threshold CPU Usage Percentage. Default: %(default)s',
        default=DEFAULT_CRIT_CPU,
        dest='CRIT_CPU',
    )

    parser.add_argument(
        '--critical-mem',
        help='Set the critical threshold Memory Usage in bytes. Default: %(default)s',
        default=DEFAULT_CRIT_MEM,
        dest='CRIT_MEM',
    )

    parser.add_argument(
        '--no-kthreads',
        help='Only scan for non kernel threads (works on Linux only). Default: %(default)s.',
        dest='NO_KTHREADS',
        action='store_true',
        default=False,
    )

    parser.add_argument(
        '--username',
        help='Only scan for processes with user name.',
        dest='USERNAME',
    )

    parser.add_argument(
        '-w', '--warning',
        help='Set the warning threshold for the number of processes (none, range or int). Default: %(default)s',
        dest='WARN',
        default=DEFAULT_WARN,
    )

    parser.add_argument(
        '--warning-cpu',
        help='Set the warning threshold CPU Usage Percentage. Default: %(default)s',
        default=DEFAULT_WARN_CPU,
        dest='WARN_CPU',
    )

    parser.add_argument(
        '--warning-mem',
        help='Set the warning threshold Memory Usage in bytes. Default: %(default)s',
        default=DEFAULT_WARN_MEM,
        dest='WARN_MEM',
    )

    parser.add_argument(
        '--no-process-names',
        help='Do not list process names in the output.',
        dest='NO_PROCESS_NAMES',
        action='store_true',
        default=False,
    )

    return parser.parse_args()


def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit:
        sys.exit(STATE_UNKNOWN)

    cpu_sum = 0
    kthreadd_pid = 0
    mem_sum = 0
    msg_uninterruptible = msg_running = msg_zombies = ''
    my_pid = os.getpid()
    proc_states = defaultdict(lambda : 0)
    procs_count = 0

    if args.CRIT_CPU or args.WARN_CPU:
        for process in psutil.process_iter():
            process.cpu_percent(interval=0)
        time.sleep(1.25)

    for process in psutil.process_iter():
        process_info = process.as_dict(attrs=['cmdline', 'name', 'status', 'memory_info', 'username', 'ppid'])

        # ignore user name (if set)
        if args.USERNAME and process_info['username'] != args.USERNAME:
            continue

        # ignore command name (if set)
        if args.COMMAND and process_info['name'] != args.COMMAND:
            continue

        # ignore command name (if set)
        if args.ARGUMENT and not args.ARGUMENT in ' '.join(process_info['cmdline']):
            continue

        # ignore myself
        if process.pid == my_pid:
            continue

        # filter kernel threads (childs of KTHREAD_PARENT)
        if args.NO_KTHREADS:
            if process_info['name'] == 'kthreadd':
                kthreadd_pid = process.pid
            else:
                if kthreadd_pid and process_info['ppid'] == kthreadd_pid:
                    continue

        procs_count += 1
        cpu_sum += process.cpu_percent(interval=0)
        mem_sum += process_info['memory_info'].rss
        proc_states[process_info['status']] += 1

        if not args.NO_PROCESS_NAMES:
            if process_info['status'] == psutil.STATUS_DISK_SLEEP:  # uninterruptible
                msg_uninterruptible += process_info['name'] + ', '

            if process_info['status'] == psutil.STATUS_RUNNING:
                msg_running += process_info['name'] + ', '

            if process_info['status'] == psutil.STATUS_ZOMBIE:
                msg_zombies += process_info['name'].replace(' <defunct>', '') + ', '

    # group some proc_states, have a look at the README for detals
    proc_states[psutil.STATUS_SLEEPING] += proc_states[psutil.STATUS_IDLE]
    del proc_states[psutil.STATUS_IDLE]
    proc_states[psutil.STATUS_STOPPED] += proc_states[psutil.STATUS_TRACING_STOP]
    del proc_states[psutil.STATUS_TRACING_STOP]

    # build the state, check the ranges
    if not lib.base2.coe(lib.base2.match_range(procs_count, args.CRIT)):
        state = STATE_CRIT
    elif not lib.base2.coe(lib.base2.match_range(procs_count, args.WARN)):
        state = STATE_WARN
    else:
        state = STATE_OK

    if not lib.base2.coe(lib.base2.match_range(cpu_sum, args.CRIT_CPU)):
        cpu_state = STATE_CRIT
    elif not lib.base2.coe(lib.base2.match_range(cpu_sum, args.WARN_CPU)):
        cpu_state = STATE_WARN
    else:
        cpu_state = STATE_OK
    state = lib.base2.get_worst(state, cpu_state)

    if not lib.base2.coe(lib.base2.match_range(mem_sum, args.CRIT_MEM)):
        mem_state = STATE_CRIT
    elif not lib.base2.coe(lib.base2.match_range(mem_sum, args.WARN_MEM)):
        mem_state = STATE_WARN
    else:
        mem_state = STATE_OK
    state = lib.base2.get_worst(state, mem_state)

    # build the message
    msg = '{} {}, '.format(procs_count, lib.base2.pluralize('task', procs_count))

    if args.CRIT_CPU or args.WARN_CPU:
        msg += '{:.1f} cpu, '.format(cpu_sum)

    if args.CRIT_MEM or args.WARN_MEM:
        msg += '{} mem, '.format(lib.base2.bytes2human(mem_sum))

    if proc_states[psutil.STATUS_DEAD]:
        msg += '{} dead, '.format(proc_states[psutil.STATUS_DEAD])

    if proc_states[psutil.STATUS_RUNNING]:
        if args.NO_PROCESS_NAMES:
            msg += '{} running, '.format(proc_states[psutil.STATUS_RUNNING])
        else:
            msg += '{} running ({}), '.format(proc_states[psutil.STATUS_RUNNING], msg_running[:-2])

    if proc_states[psutil.STATUS_SLEEPING]:
        msg += '{} sleeping, '.format(proc_states[psutil.STATUS_SLEEPING])

    if proc_states[psutil.STATUS_STOPPED]:
        msg += '{} stopped, '.format(proc_states[psutil.STATUS_STOPPED])

    if proc_states[psutil.STATUS_DISK_SLEEP]:
        if args.NO_PROCESS_NAMES:
            msg += '{} uninterruptible, '.format(proc_states[psutil.STATUS_DISK_SLEEP])
        else:
            msg += '{} uninterruptible ({}), '.format(proc_states[psutil.STATUS_DISK_SLEEP], msg_uninterruptible[:-2])

    if proc_states[psutil.STATUS_ZOMBIE]:
        if args.NO_PROCESS_NAMES:
            msg += '{} {}, '.format(proc_states[psutil.STATUS_ZOMBIE], lib.base2.pluralize('zombie', proc_states[psutil.STATUS_ZOMBIE]))
        else:
            msg += '{} {} ({}), '.format(proc_states[psutil.STATUS_ZOMBIE], lib.base2.pluralize('zombie', proc_states[psutil.STATUS_ZOMBIE]), msg_zombies[:-2])

    # build perfdata
    perfdata = ''
    perfdata += lib.base2.get_perfdata('procs', procs_count, None, args.WARN, args.CRIT, 0, None)
    perfdata += lib.base2.get_perfdata('procs_sleeping', proc_states[psutil.STATUS_SLEEPING], None, None, None, 0, None)
    perfdata += lib.base2.get_perfdata('procs_running', proc_states[psutil.STATUS_RUNNING], None, None, None, 0, None)
    perfdata += lib.base2.get_perfdata('procs_uninterruptible', proc_states[psutil.STATUS_DISK_SLEEP], None, None, None, 0, None)
    perfdata += lib.base2.get_perfdata('procs_zombies', proc_states[psutil.STATUS_ZOMBIE], None, None, None, 0, None)
    perfdata += lib.base2.get_perfdata('procs_stopped', proc_states[psutil.STATUS_STOPPED], None, None, None, 0, None)
    perfdata += lib.base2.get_perfdata('procs_dead', proc_states[psutil.STATUS_DEAD], None, None, None, 0, None)

    if args.CRIT_CPU or args.WARN_CPU:
        perfdata += lib.base2.get_perfdata('procs_cpu', cpu_sum, '%', None, None, 0, 100)

    if args.CRIT_MEM or args.WARN_MEM:
        perfdata += lib.base2.get_perfdata('procs_mem', mem_sum, None, None, None, 0, None)

    lib.base2.oao(msg[:-2], state, perfdata, always_ok=args.ALWAYS_OK)


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print_exc()
        sys.exit(STATE_UNKNOWN)
