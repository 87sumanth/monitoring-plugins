#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

import os

activate_this = False
venv_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'monitoring-plugins-venv2')
if os.path.exists(venv_path):
    activate_this = os.path.join(venv_path, 'bin/activate_this.py')

if os.getenv('MONITORING_PLUGINS_VENV2'):
    activate_this = os.path.join(os.getenv('MONITORING_PLUGINS_VENV2') + 'bin/activate_this.py')

if activate_this and os.path.isfile(activate_this):
    exec(open(activate_this).read(), {'__file__': activate_this})


__author__ = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2021041202'

DESCRIPTION = 'This check prints various statistics for all running Docker containers, in much the same way as the Unix application top, using the "docker stats" command.'

DEFAULT_WARN_CPU  = 80      # %
DEFAULT_CRIT_CPU  = 90      # %

DEFAULT_COUNT = 5           # measurements; if check runs once per minute, this is a 5 minute period

DEFAULT_WARN_MEM  = 90      # %
DEFAULT_CRIT_MEM  = 95      # %


#====================
from lib.globals2 import *

import lib.args2
import lib.base2
import lib.db_sqlite2

import argparse
from traceback import print_exc


def parse_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument(
        '-V', '--version',
        action='version',
        version='%(prog)s: v{} by {}'.format(__version__, __author__)
        )

    parser.add_argument('--always-ok',
        help='Always returns OK.',
        dest='ALWAYS_OK',
        action='store_true',
        default=False,
        )

    parser.add_argument('--count',
        help='Number of times the value has to be above the given thresholds. Default: %(default)s',
        dest='COUNT',
        type=int,
        default=DEFAULT_COUNT,
        )
    
    parser.add_argument(
        '--critical-cpu',
        help='Set the critical threshold CPU Usage Percentage. Default: %(default)s',
        default=DEFAULT_CRIT_CPU,
        dest='CRIT_CPU',
    )

    parser.add_argument(
        '--critical-mem',
        help='Set the critical threshold Memory Usage Percentage. Default: %(default)s',
        default=DEFAULT_CRIT_MEM,
        dest='CRIT_MEM',
    )

    parser.add_argument(
        '--warning-cpu',
        help='Set the warning threshold CPU Usage Percentage. Default: %(default)s',
        default=DEFAULT_WARN_CPU,
        dest='WARN_CPU',
    )

    parser.add_argument(
        '--warning-mem',
        help='Set the warning threshold Memory Usage Percentage. Default: %(default)s',
        default=DEFAULT_WARN_MEM,
        dest='WARN_MEM',
    )

    return parser.parse_args()


def get_cpu_from_db(conn, container, threshold):
    result = lib.base2.coe(lib.db_sqlite2.select(conn, 
        '''
        SELECT count(*) as cnt
        FROM cpu
        WHERE container = :container and cpu_usage >= :threshold
        ''',
        {'container': container, 'threshold': threshold},
        fetchone=True
    ))
    return int(result['cnt'])


def get_net_from_db(conn, container):
    result = lib.base2.coe(lib.db_sqlite2.select(conn, 
        '''
        SELECT *
        FROM net
        WHERE container = :container
        ''',
        {'container': container},
    ))
    return result


def get_block_from_db(conn, container):
    result = lib.base2.coe(lib.db_sqlite2.select(conn, 
        '''
        SELECT *
        FROM block
        WHERE container = :container
        ''',
        {'container': container},
    ))
    return result


def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        args = parse_args()
    except SystemExit as e:
        exit(STATE_UNKNOWN)

    # we need cpu and memory from docker perspective
    cmd = 'docker info'
    stdout, stderr, retc = lib.base2.coe(lib.base2.shell_exec(cmd, shell=True))
    if not stdout:
        lib.base2.oao('{}'.format('Unable to fetch docker info.'), STATE_UNKNOWN)
    try:
        strpos1 = stdout.find('CPUs: ') + 6
        strpos2 = stdout.find('\n', strpos1)
        host_cpus = int(stdout[strpos1:strpos2])
        strpos1 = stdout.find('Total Memory: ') + 14
        strpos2 = stdout.find('\n', strpos1)
        host_mem = stdout[strpos1:strpos2]
    except:
        lib.base2.oao('{}'.format('Unable to compute docker info.'), STATE_UNKNOWN)


    # create the db tables
    definition = '''
                container TEXT NOT NULL,
                cpu_usage REAL NOT NULL
        '''
    conn = lib.base2.coe(lib.db_sqlite2.connect(filename='docker-stats.db'))
    lib.base2.coe(lib.db_sqlite2.create_table(conn, definition, table='cpu'))
    lib.db_sqlite2.create_index(conn, 'container', table='cpu')

    definition = '''
                container TEXT NOT NULL,
                rx REAL NOT NULL,
                tx REAL NOT NULL,
                timestamp INT NOT NULL
        '''
    conn = lib.base2.coe(lib.db_sqlite2.connect(filename='docker-stats.db'))
    lib.base2.coe(lib.db_sqlite2.create_table(conn, definition, table='net'))
    lib.db_sqlite2.create_index(conn, 'container', table='net', unique=True)

    definition = '''
                container TEXT NOT NULL,
                block_in REAL NOT NULL,
                block_out REAL NOT NULL,
                timestamp INT NOT NULL
        '''
    conn = lib.base2.coe(lib.db_sqlite2.connect(filename='docker-stats.db'))
    lib.base2.coe(lib.db_sqlite2.create_table(conn, definition, table='block'))
    lib.db_sqlite2.create_index(conn, 'container', table='block', unique=True)


    # get the container statistics for all running containers

    # CONTAINER ID   NAME            CPU %     MEM USAGE / LIMIT     MEM %     NET I/O       BLOCK I/O        PIDS
    # 0d42d796123b   graylog         204.20%   215.6MiB / 3.702GiB   5.69%     578B / 0B     0B / 0B          21
    # 40cd9c3978b3   elasticsearch   188.77%   634.1MiB / 3.702GiB   16.73%    508B / 0B     1.44MB / 0B      26
    # b48543f756e6   mongo           0.27%     73.84MiB / 3.702GiB   1.95%     760B / 116B   6.59MB / 480kB   33

    cmd = 'docker stats --no-stream'
    stdout, stderr, retc = lib.base2.coe(lib.base2.shell_exec(cmd, shell=True))
    if (stderr or retc != 0):
        lib.base2.oao('{}'.format(stderr), STATE_UNKNOWN)


    # init some vars
    msg, msg_header = '', ''
    state = STATE_OK
    perfdata = ''
    table_values = []


    # evaluate results
    perfdata += lib.base2.get_perfdata('cpu', host_cpus, None, None, None, 0, None)
    perfdata += lib.base2.get_perfdata('ram', lib.base2.human2bytes(host_mem), 'b', None, None, 0, None)

    now = lib.base2.now()
    host_mem_usage, rx_bps, tx_bps, block_in_bytespersec, block_out_bytespersec = 0, 0, 0, 0, 0
    containers = lib.base2.mltext2array(stdout, skip_header=True, sort_key=1)

    for container in containers:
        try:
            container_id, name, cpu_percent, mem_usage, tmp, mem_limit, mem_percent, net_in, tmp, net_out, block_in, tmp, block_out, pids = container
        except:
            continue

        # divide by number of cores (got by docker info)
        cpu_usage = round(float(cpu_percent.replace('%', '').strip()) / host_cpus, 1)
        perfdata += lib.base2.get_perfdata('{}_cpu_usage'.format(name), cpu_usage, '%', args.WARN_CPU, args.CRIT_CPU, 0, 100)

        # save trend data to local sqlite database, limited to "count" rows max.
        lib.base2.coe(lib.db_sqlite2.insert(conn, {'container': name, 'cpu_usage': cpu_usage}, table='cpu'))
        lib.base2.coe(lib.db_sqlite2.cut(conn, max=args.COUNT*len(containers), table='cpu'))
        lib.base2.coe(lib.db_sqlite2.commit(conn))

        # alert when container cpu_usage is exceeded
        # my container state is not ok, if in every of my historic rows the cpu value is above the threshold
        if get_cpu_from_db(conn, name, args.CRIT_CPU) == args.COUNT:
            cpu_state = STATE_CRIT
        elif get_cpu_from_db(conn, name, args.WARN_CPU) == args.COUNT:
            cpu_state = STATE_WARN
        else:
            cpu_state = STATE_OK
        if cpu_state != STATE_OK:
            msg += '"{}" cpu {}% {}, '.format(name, cpu_usage, lib.base2.state2str(cpu_state))
        state = lib.base2.get_worst(cpu_state, state)

        # alert when container mem_usage is exceeded
        mem_usage = float(mem_percent.replace('%', '').strip())
        perfdata += lib.base2.get_perfdata('{}_mem_usage'.format(name), mem_usage, '%', args.WARN_CPU, args.CRIT_CPU, 0, 100)
        mem_state = lib.base2.get_state(mem_usage, args.WARN_MEM, args.CRIT_MEM)
        if mem_state != STATE_OK:
            msg += '"{}" memory {}% {}, '.format(name, mem_usage, lib.base2.state2str(mem_state))
        state = lib.base2.get_worst(mem_state, state)

        # for alerting when docker consumes too much host ram
        host_mem_usage += mem_usage

        # net rx, tx
        # since we do not know the bandwidth, we cannot issue a warning here
        # but we can calculate the bps
        rx = lib.base2.human2bytes(net_in)
        perfdata += lib.base2.get_perfdata('{}_rx'.format(name), rx, 'b', None, None, 0, None)
        tx = lib.base2.human2bytes(net_out)
        perfdata += lib.base2.get_perfdata('{}_tx'.format(name), tx, 'b', None, None, 0, None)

        rx *= 8
        tx *= 8
        prev_net = get_net_from_db(conn, name)
        if prev_net:
            timestamp_diff = now - prev_net[0]['timestamp'] # in seconds
            rx_bps = int((rx - prev_net[0]['rx']) / timestamp_diff)
            perfdata += lib.base2.get_perfdata('{}_rx_bps'.format(name), rx_bps, None, None, None, 0, None)
            tx_bps = int((tx - prev_net[0]['tx']) / timestamp_diff)
            perfdata += lib.base2.get_perfdata('{}_tx_bps'.format(name), tx_bps, None, None, None, 0, None)
        lib.base2.coe(lib.db_sqlite2.replace(conn, {'container': name, 'rx': rx, 'tx': tx, 'timestamp': now}, table='net'))

        # block_in, block_out
        # since we do not know the bandwidth, we cannot issue a warning here
        # but we can calculate bytes per second
        block_in = lib.base2.human2bytes(block_in)
        perfdata += lib.base2.get_perfdata('{}_block_in'.format(name), block_in, 'b', None, None, 0, None)
        block_out = lib.base2.human2bytes(block_out)
        perfdata += lib.base2.get_perfdata('{}_block_out'.format(name), block_out, 'b', None, None, 0, None)

        prev_block = get_block_from_db(conn, name)
        if prev_block:
            timestamp_diff = now - prev_block[0]['timestamp'] # in seconds
            block_in_bytespersec = int((block_in - prev_block[0]['block_in']) / timestamp_diff)
            perfdata += lib.base2.get_perfdata('{}_block_in_bytespersec'.format(name), block_in_bytespersec, None, None, None, 0, None)
            block_out_bytespersec = int((block_out - prev_block[0]['block_out']) / timestamp_diff)
            perfdata += lib.base2.get_perfdata('{}_block_out_bytespersec'.format(name), block_out_bytespersec, None, None, None, 0, None)
        lib.base2.coe(lib.db_sqlite2.replace(conn, {'container': name, 'block_in': block_in, 'block_out': block_out, 'timestamp': now}, table='block'))


        table_values.append({
            'name': name,
            'cpu_usage': cpu_usage,
            'cpu_state': lib.base2.state2str(cpu_state, empty_ok=False),
            'mem_usage': mem_usage,
            'mem_state': lib.base2.state2str(mem_state, empty_ok=False),
            'rx': lib.base2.bps2human(rx_bps),
            'tx': lib.base2.bps2human(tx_bps),
            'block_in': lib.base2.bytes2human(block_in_bytespersec),
            'block_out': lib.base2.bytes2human(block_out_bytespersec),
            })


    # we don't need the database any more: save data and close connection
    lib.db_sqlite2.commit(conn)
    lib.db_sqlite2.close(conn)

    perfdata += lib.base2.get_perfdata('host_mem_usage', host_mem_usage, '%', args.WARN_MEM, args.CRIT_MEM, 0, 100)
    host_mem_state = lib.base2.get_state(host_mem_usage, args.WARN_MEM, args.CRIT_MEM)
    if host_mem_state != STATE_OK:
        msg += 'Host memory {}% {}, '.format(host_mem_usage, lib.base2.state2str(host_mem_state))
    state = lib.base2.get_worst(host_mem_state, state)


    # create output
    if state == STATE_OK:
        msg = 'Everything is ok.\n\n'
    else:
        msg = msg[:-2] + '\n\n'
    if len(table_values) > 0:
        msg += lib.base2.get_table(
            table_values,
            ['name', 'cpu_usage', 'cpu_state', 'mem_usage', 'mem_state', 'rx', 'tx', 'block_in', 'block_out'],
            header=['Container', 'CPU %', 'State', 'Mem % ', 'State', 'RX bps   ', 'TX bps   ', 'BlockIn/s', 'BlockOut/s'],
            )

    # over and out
    lib.base2.oao(msg, state, perfdata)


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print_exc()
        exit(STATE_UNKNOWN)
