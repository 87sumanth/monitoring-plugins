#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/-/blob/master/CONTRIBUTING.md

__author__  = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020030901'

DESCRIPTION = 'Mainly provides utilization percentages for each specific CPU time. Takes a time period into account: the cpu usage within a certain amount of time has to be equal or above given thresholds before a warning is raised.'

DEFAULT_WARN  = 80      # %
DEFAULT_CRIT  = 90      # %
DEFAULT_COUNT = 5       # measurements; if check runs once per minute, this is a 5 minute interval


#====================
from lib.globals import *

import argparse
from traceback import print_exc
try:
    import psutil
except ImportError, e:
    print('Python module "psutil" is not installed.')
    exit(STATE_UNKNOWN)
import sqlite3

from lib.output import unpack_perfdata


def define_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument('-V', '--version',
        action = 'version',
        version = '{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
        )

    parser.add_argument('-w', '--warning',
        help = 'Set the warning threshold CPU Usage Percentage. Default: %(default)s',
        dest = 'WARN',
        type = float,
        default = DEFAULT_WARN,
        )

    parser.add_argument('-c', '--critical',
        help = 'Set the critical threshold CPU Usage Percentage. Default: %(default)s',
        dest = 'CRIT',
        type = float,
        default = DEFAULT_CRIT,
        )

    parser.add_argument('--count',
        help = 'Number of times the value has to be above the given thresholds. Default: %(default)s',
        dest = 'COUNT',
        type = int,
        default = DEFAULT_COUNT,
        )
    
    return parser.parse_args()


# https://docs.python.org/2/library/sqlite3.html
def insert_into_db(db, values, count):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    # create table if it does not exist
    try:
        c.execute('''
            CREATE TABLE IF NOT EXISTS check_values (
                user REAL NOT NULL, 
                system REAL NOT NULL,
                iowait REAL NOT NULL,
                cpu_usage REAL NOT NULL
                )
            ''')
    except:
        print('{} cannot be written'.format(db))
        exit(STATE_UNKNOWN)

    # insert a row of data (here named values from a dictionary)
    c.execute('INSERT INTO check_values VALUES (:user, :system, :iowait, :cpu_usage)', values)

    # leave only the latest "count" records, using the sqlite built-in "rowid"
    c.execute('''
        DELETE FROM check_values
        WHERE rowid IN (
            SELECT rowid
            FROM check_values
            ORDER BY rowid DESC
            LIMIT -1
            OFFSET ?
        )
        ''', (count, ))

    # Save (commit) the changes
    conn.commit()

    # We can close the connection if we are done with it.
    # Just be sure any changes have been committed or they will be lost.
    conn.close()


def get_from_db(db, threshold):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    c.execute('''
        SELECT count(*)
        FROM check_values
        WHERE user > ? or system > ? or iowait > ? or cpu_usage > ?
        ''', (threshold, threshold, threshold, threshold))
    result = c.fetchone()

    # We can close the connection if we are done with it.
    # Just be sure any changes have been committed or they will be lost.
    conn.close()

    return result[0]


def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        parsed = define_args()
    except SystemExit as e:
        exit(STATE_UNKNOWN)

    stats = {}
    extstats = {}

    # Grab CPU stats using psutil's cpu_times_percent
    # https://git.linuxfabrik.ch/linuxfabrik-icinga-plugins/checks-linux/issues/57: changed from 0.25 to 1.25
    cpu_times_percent = psutil.cpu_times_percent(interval=1.25, percpu=False)
    stats['cpu_usage'] = 100.0 - getattr(cpu_times_percent, 'idle')

    if hasattr(cpu_times_percent, 'guest'):         stats['guest']      = getattr(cpu_times_percent, 'guest')
    if hasattr(cpu_times_percent, 'guest_nice'):    stats['guest_nice'] = getattr(cpu_times_percent, 'guest_nice')
    if hasattr(cpu_times_percent, 'iowait'):        stats['iowait']     = getattr(cpu_times_percent, 'iowait')
    if hasattr(cpu_times_percent, 'irq'):           stats['irq']        = getattr(cpu_times_percent, 'irq')
    if hasattr(cpu_times_percent, 'nice'):          stats['nice']       = getattr(cpu_times_percent, 'nice')
    if hasattr(cpu_times_percent, 'softirq'):       stats['softirq']    = getattr(cpu_times_percent, 'softirq')
    if hasattr(cpu_times_percent, 'steal'):         stats['steal']      = getattr(cpu_times_percent, 'steal')
    if hasattr(cpu_times_percent, 'system'):        stats['system']     = getattr(cpu_times_percent, 'system')
    if hasattr(cpu_times_percent, 'user'):          stats['user']       = getattr(cpu_times_percent, 'user')
    

    # Additional CPU stats (number of events not as %; psutil>=4.1.0)
    # ctx_switches: number of context switches (voluntary + involuntary) since boot
    # interrupts: number of interrupts since boot
    # soft_interrupts: number of software interrupts since boot. Always set to 0 on Windows and SunOS.
    # syscalls: number of system calls since boot. Always set to 0 on Linux.
    if psutil.__version__ >= '4.1.0':
        cpu_stats = psutil.cpu_stats()
        if hasattr(cpu_stats, 'ctx_switches'):      extstats['ctx_switches']       = getattr(cpu_stats, 'ctx_switches')
        if hasattr(cpu_stats, 'interrupts'):        extstats['interrupts']         = getattr(cpu_stats, 'interrupts')
        if hasattr(cpu_stats, 'soft_interrupts'):   extstats['soft_interrupts']    = getattr(cpu_stats, 'soft_interrupts')


    # save trend data to local sqlite database, limited to "count" rows max.
    insert_into_db('/tmp/cpu-usage.db', stats, parsed.COUNT)


    # sort by highest value
    cpu_usage = stats['cpu_usage']
    del stats['cpu_usage']
    stats = sorted(stats.items(), key=lambda x: x[1], reverse=True)


    msg = ''
    perfdata = ''
    state = STATE_OK


    # now, calculate the WARN or CRIT.
    # overall status is not ok, if ...
    #   in a row in any column there is a value above the threshold
    #   and this is true for every row 
    if get_from_db('/tmp/cpu-usage.db', parsed.CRIT) == parsed.COUNT:
        state = STATE_CRIT
    elif get_from_db('/tmp/cpu-usage.db', parsed.WARN) == parsed.COUNT:
        state = STATE_WARN


    # build the message
    perfdata += unpack_perfdata('cpu-usage', cpu_usage, '%', parsed.WARN, parsed.CRIT, 0, 100)
    # line1: values > 0%
    # line2: values == 0%
    line1, line2 = '', ''
    for i in range(len(stats)):
        if stats[i][1] != 0:
            line1 += '{}: {}%, '.format(stats[i][0], stats[i][1])
        else:
            line2 += '{}: {}%, '.format(stats[i][0], stats[i][1])
        perfdata += unpack_perfdata(stats[i][0], stats[i][1], '%', None, None, 0, 100)
    msg += '{}%'.format(cpu_usage)
    if  line1:
        msg += ' - ' + line1[:-2]
    if line2:
        msg += '\n' + line2[:-2]


    if extstats:
        msg += '\n'
        for key in extstats:
            msg += '{}: {}, '.format(key, extstats[key])
            perfdata += unpack_perfdata(key, extstats[key], 'c', None, None, 0, None)
        msg = msg[:-2]


    # over and out
    print(msg.strip() + '|' + perfdata.strip())
    exit(state)


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print_exc()
        exit(STATE_UNKNOWN)
