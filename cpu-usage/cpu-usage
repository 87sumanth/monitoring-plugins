#! /usr/bin/env python2
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://nagios-plugins.org/doc/guidelines.html

__author__  = 'Linuxfabrik GmbH, Zurich/Switzerland'
__version__ = '2020010901'

DESCRIPTION = 'Mainly provides utilization percentages for each specific CPU time. Takes a time period into account: the cpu usage within a certain amount of time has to be equal or above given thresholds before a warning is raised.'

DEFAULT_WARN  = 50      # %
DEFAULT_CRIT  = 70      # %
DEFAULT_COUNT = 5       # measurements; if check runs once per minute, this is a 5 minute interval


#====================
import argparse
import psutil
import sqlite3

from lib.globals import *
from lib.output import unpack_perfdata


def define_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument('-V', '--version',
        action = 'version',
        version = '{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
        )

    parser.add_argument('-w', '--warning',
        help = 'Set the warning threshold CPU Usage Percentage. Default: %(default)s',
        dest = 'WARN',
        type = float,
        default = DEFAULT_WARN,
        )

    parser.add_argument('-c', '--critical',
        help = 'Set the critical threshold CPU Usage Percentage. Default: %(default)s',
        dest = 'CRIT',
        type = float,
        default = DEFAULT_CRIT,
        )

    parser.add_argument('-i', '--count',
        help = 'Number of times the value has to be above the given thresholds. Default: %(default)s',
        dest = 'COUNT',
        type = int,
        default = DEFAULT_COUNT,
        )
    
    return parser.parse_args()


# https://docs.python.org/2/library/sqlite3.html
def insert_into_db(db, values, count):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    # create table if it does not exist
    c.execute('''
        CREATE TABLE IF NOT EXISTS check_values (
            user REAL NOT NULL, 
            system REAL NOT NULL,
            iowait REAL NOT NULL,
            cpu_usage REAL NOT NULL
            )
        ''')

    # insert a row of data (here named values from a dictionary)
    c.execute('INSERT INTO check_values VALUES (:user, :system, :iowait, :cpu_usage)', values)

    # leave only the latest "count" records, using the sqlite built-in "rowid"
    c.execute('''
        DELETE FROM check_values
        WHERE rowid IN (
            SELECT rowid
            FROM check_values
            ORDER BY rowid DESC
            LIMIT -1
            OFFSET ?
        )
        ''', (count, ))

    # Save (commit) the changes
    conn.commit()

    # We can close the connection if we are done with it.
    # Just be sure any changes have been committed or they will be lost.
    conn.close()


def get_from_db(db, threshold):
    conn = sqlite3.connect(db)

    c = conn.cursor()

    c.execute('''
        SELECT count(*)
        FROM check_values
        WHERE user > ? or system > ? or iowait > ? or cpu_usage > ?
        ''', (threshold, threshold, threshold, threshold))
    result = c.fetchone()

    # We can close the connection if we are done with it.
    # Just be sure any changes have been committed or they will be lost.
    conn.close()

    return result[0]


def main():
    # parse the command line, exit with UNKNOWN if it fails
    try:
        parsed = define_args()
    except SystemExit as e:
        exit(STATE_UNKNOWN)

    stats = {}

    # Grab CPU stats using psutil's cpu_times_percent
    # Get all possible values for CPU stats: user, system, idle,
    # nice (UNIX), iowait (Linux), irq (Linux, FreeBSD), steal (Linux 2.6.11+)

    cpu_times_percent = psutil.cpu_times_percent(interval=0.25, percpu=False)
    for stat in ['user', 'system', 'idle', 'nice', 'iowait',
                 'irq', 'softirq', 'steal', 'guest', 'guest_nice']:
        if hasattr(cpu_times_percent, stat):
            stats[stat] = getattr(cpu_times_percent, stat)
    stats['cpu_usage'] = round(100 - getattr(cpu_times_percent, 'idle'), 1)


    # Additional CPU stats (number of events not as %; psutil>=4.1.0)
    # ctx_switches: number of context switches (voluntary + involuntary) since boot
    # interrupts: number of interrupts since boot
    # soft_interrupts: number of software interrupts since boot. Always set to 0 on Windows and SunOS.
    # syscalls: number of system calls since boot. Always set to 0 on Linux.

    if psutil.__version__ >= '4.1.0':
        cpu_stats = psutil.cpu_stats()
        for stat in ['ctx_switches', 'interrupts', 'soft_interrupts', 'syscalls']:
            if hasattr(cpu_stats, stat):
                stats[stat] = getattr(cpu_stats, stat)


    # save trend data to local sqlite database, limited to "count" rows max.
    insert_into_db('/tmp/cpu-usage.db', stats, parsed.COUNT)


    msg = ''
    perfdata = ''
    state = STATE_OK


    # now, calculate the WARN or CRIT.
    # overall status is not ok, if ...
    #   in a row in any column there is a value above the threshold
    #   and this is true for every row 
    if get_from_db('/tmp/cpu-usage.db', parsed.CRIT) == parsed.COUNT:
        state = STATE_CRIT
    elif get_from_db('/tmp/cpu-usage.db', parsed.WARN) == parsed.COUNT:
        state = STATE_WARN


    # build the message
    msg += 'CPU: {}% - user: {}%, system: {}%, iowait: {}%\n'.format(stats['cpu_usage'], stats['user'], stats['system'], stats['iowait'])
    msg += 'nice: {}%, irq: {}%, steal: {}%\n'.format(stats['nice'], stats['irq'], stats['steal'])
    if psutil.__version__ >= '4.1.0':
        msg += 'ctx_switches: {}, interrupts: {}, soft_interrupts: {}'.format(stats['ctx_switches'], stats['interrupts'], stats['soft_interrupts'])

    # build perfdata
    perfdata += unpack_perfdata('cpu-usage', stats['cpu_usage'], '%', parsed.WARN, parsed.CRIT, 0, 100)
    perfdata += unpack_perfdata('user', stats['user'], '%', parsed.WARN, parsed.CRIT, 0, 100)
    perfdata += unpack_perfdata('system', stats['system'], '%', parsed.WARN, parsed.CRIT, 0, 100)
    perfdata += unpack_perfdata('iowait', stats['iowait'], '%', parsed.WARN, parsed.CRIT, 0, 100)

    perfdata += unpack_perfdata('nice', stats['nice'], '%', None, None, 0, 100)
    perfdata += unpack_perfdata('irq', stats['irq'], '%', None, None, 0, 100)
    perfdata += unpack_perfdata('steal', stats['steal'], '%', None, None, 0, 100)

    if psutil.__version__ >= '4.1.0':
        perfdata += unpack_perfdata('ctx_switches', stats['ctx_switches'], 'c', None, None, 0, None)
        perfdata += unpack_perfdata('interrupts', stats['interrupts'], 'c', None, None, 0, None)
        perfdata += unpack_perfdata('soft_interrupts', stats['soft_interrupts'], 'c', None, None, 0, None)

    # over and out
    print(msg.strip() + '|' + perfdata.strip())
    exit(state)


if __name__ == '__main__':
    main()
